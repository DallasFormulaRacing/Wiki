{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Dallas Formula Racing's Embedded Team","text":""},{"location":"#projects","title":"Projects","text":"<ul> <li> <p>The Data AcQuisition (DAQ), or NoTeC, is a device based on the stm32f429zi which samples from the ECU and multiple analog and digital data sources, eventually relaying it to a Raspberry Pi on the car, as well as saving it locally in CSV format. It acts as a sensor hub, and is written on top of the STM32 toolchain in C++. </p> </li> <li> <p>The Dashboard Display is the HUD of the car, it takes data from the DAQ and displays it to the drivers. The project also runs on an STM device, with a Yocto linux image and a \"front end\" written with help of the Qt5 libraries.</p> </li> <li> <p>The documentation is split into the DAQ and Dashboard projects, in either project the Dev Guide is the best way to set up your environment and get to programming. The wiki is still mostly in progress, and will require more work. Contributing to the wiki in places where it is lacking is one of the best ways to familiarize yourself with the code base.</p> </li> </ul>"},{"location":"Dashboard%20Display/Dev%20Guide/","title":"Developer's Guide","text":""},{"location":"Dashboard%20Display/Dev%20Guide/#getting-started","title":"Getting Started","text":"<p>This section covers the essential tools required for the device workflow. The OS Flashing Tools and Logging In pages consists of tools you will use often in the development process. The Starter Package, Developer Package, and Running Qt5 Apps pages are all based on example OS images and steps provided by ST. Although on the Starter Package is essential for a brand new stm32mp1 board, I highly suggest going through these pages to understand the workflow and different possible levels of customizations behind supporting a custom Linux image. </p> <ul> <li> OS Flashing Tools \u2013 Install initial dependencies installing the OS to an SD card.</li> <li> Starter Package \u2013 Install a demo launcher and partition the SD card for the file system.</li> <li> Terminal and Serial Output \u2013 Accessing the device terminal and receiving serial output from UART.</li> <li> Developer Package \u2013 Build apps based on the Linux kernel using a pre-built, minimal OS.</li> <li> Running Qt5 Apps \u2013 Build an example custom Linux image packaged with the Qt version 5 framework.</li> </ul>"},{"location":"Dashboard%20Display/Dev%20Guide/developer-package/","title":"Developer Package","text":"<p>This enables:</p> <ul> <li>Cross compilation</li> <li>Using the required version of the C compiler (GCC)</li> <li>etc.</li> </ul> <p>To follow along the official tutorial, go to  Section 5: Installing the components to develop software running on Arm Cortex-A (OpenSTLinux distribution).</p> <p>Warning</p> <p>Before proceeding, install OpenSTLinux by using the Starter Package.</p>"},{"location":"Dashboard%20Display/Dev%20Guide/developer-package/#software-development-kit-sdk","title":"Software Development Kit (SDK)","text":""},{"location":"Dashboard%20Display/Dev%20Guide/developer-package/#installing-the-sdk","title":"Installing the SDK","text":"<p>Create and move to your working directory: <pre><code>mkdir developer-package\ncd developer-package\n</code></pre></p> <p>Create and move to a sub-folder to keep your SDK installer: <pre><code>mkdir sdk-installation\ncd sdk-installation\n</code></pre></p> <ul> <li>Download the SDK from the OpenSTLinux Developer Package page.</li> <li>Run the <code>uname -m</code> command and take note of your host architecture.</li> <li>Download the package labeled <code>Yocto_SDK[your_host_architecture]</code>.</li> <li>Move this package to <code>developer-package/sdk-installation</code></li> </ul> <p>Note</p> <p>This example follows a host architecture of <code>x86_64</code>, so keep in mind that file/folder names may be slightly different.</p> <p>Extract the compressed files:</p> <pre><code>tar xvf en.SDK-x86_64-stm32mp1-openstlinux-6.1-yocto-mickledore-mp1-v23.06.21.tar.gz\n</code></pre> <p>Make a new folder from your working directory to keep your installer. For the sake of this example, here is my working directory so far:</p> <pre><code>developer-package/\n|-- sdk-installation/\n    |-- en.SDK-x86_64-stm32mp1-openstlinux-6.1-yocto-mickledore-mp1-v23.06.21.tar.gz\n    |-- en.SDK-x86_64-stm32mp1-openstlinux-6.1-yocto-mickledore-mp1-v23.06.21/\n        |-- yocto manifest files\n        |-- installation shell script (ends with .sh)\n|-- SDK\n    |-- We will install the SDK here\n</code></pre> <p>From the <code>sdk-installation/</code> folder, mark the installation script as an executable:</p> <pre><code>chmod +x stm32mp1-openstlinux-___-v23.06.21/sdk/st-image-weston-___-v23.06.21.sh\n</code></pre> <p>Warning</p> <p>I am intentionally shortening the names with <code>___</code>. Remember, tab completion is your friend! You do not have to manually type this.</p> <p>Run the installation script, and store it in <code>developer-package/SDK/</code>:</p> <ul> <li>The <code>-d</code> flag allows you to specify the target directory to keep the SDK.</li> </ul> <pre><code>./stm32mp1-openstlinux-___-v23.06.21/sdk/st-image-weston-___-v23.06.21.sh -d ./../SDK/\n</code></pre>"},{"location":"Dashboard%20Display/Dev%20Guide/developer-package/#sourceactivate-the-sdk","title":"Source/Activate the SDK","text":"<p>From the <code>developer-package/</code> directory, source the SDK:</p> <ul> <li>Alternatively, you can use <code>.</code> instead of <code>source</code>.</li> </ul> <pre><code>source SDK/environment-setup-cortexa7t2hf-neon-vfpv4-ostl-linux-gnueabi\n</code></pre> <p>This must be done for every new terminal instance that is going to cross-compile.</p>"},{"location":"Dashboard%20Display/Dev%20Guide/developer-package/#verifying-the-sdk","title":"Verifying the SDK","text":"<p>Call the following environment variables. If successful, the terminal will respond with feedback. Otherwise, the terminal will respond with an empty line.</p> <p>Check the target architecture:</p> <pre><code>echo $ARCH\n</code></pre> <p>Check the toolchain prefix:</p> <pre><code>echo $CROSS_COMPILE\n</code></pre> <p>Check the C compiler version:</p> <pre><code>$CC --version\n</code></pre> <p>Check the SDK version:</p> <pre><code>echo $OECORE_SDK_VERSION\n</code></pre>"},{"location":"Dashboard%20Display/Dev%20Guide/developer-package/#running-a-user-space-application","title":"Running a User-space Application","text":"<p>Suppose that we have a program that we want to run on the stm32mp1 device. We will need to leverage the SDK to cross-compile the application to be able to run on the target device's computer architecture and hardware.</p>"},{"location":"Dashboard%20Display/Dev%20Guide/developer-package/#cross-compiling","title":"Cross-compiling","text":"<p>First, source the SDK. Make sure to re-do this step if you create a new terminal instance.</p> <p>Create the application directory:</p> <pre><code>mkdir hello_world_example\ncd hello_world_example\n</code></pre> <p>Add the following <code>hello_world_example.c</code> source code and Makefile:</p> <pre><code>// SPDX-identifier: GPL-2.0\n/*\n * Copyright (C) STMicroelectronics SA 2018\n *\n * Authors: Jean-Christophe Trotin &lt;jean-christophe.trotin@st.com&gt;\n *\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char **argv)\n{\n    int i =11;\n\n    printf(\"\\nUser space example: hello world from STMicroelectronics\\n\");\n    setbuf(stdout,NULL);\n    while (i--) {\n        printf(\"%i \", i);\n        sleep(1);\n    }\n    printf(\"\\nUser space example: goodbye from STMicroelectronics\\n\");\n\n    return(0);\n}\n</code></pre> <pre><code>PROG = hello_world_example\nSRCS = hello_world_example.c\nOBJS = $(SRCS:.c=.o)\n\nCLEANFILES = $(PROG)\nINSTALL_DIR = ./install_artifact/usr/local/bin\n\n# Add / change option in CFLAGS if needed\n# CFLAGS += &lt;new option&gt;\n\n$(PROG):  $(OBJS)\n    $(CC) $(CFLAGS) -o $(PROG) $(OBJS)\n\n.c.o:\n    $(CC) $(CFLAGS) -c $&lt; -o $@\n\nall: $(PROG)\n\n\nclean:\n    rm -f $(CLEANFILES) $(patsubst %.c,%.o, $(SRCS)) *~\n\ninstall: $(PROG)\n    mkdir -p $(INSTALL_DIR)\n    install $(PROG) $(INSTALL_DIR)\n</code></pre> <p>You should have the following:</p> <pre><code>developer-package/\n|-- sdk-installation/\n|-- SDK/\n|-- hello_world_example/\n    |-- hello_world_example.c\n    |-- Makefile\n</code></pre> <p>Note that the Makefile is using flags belonging to the SDK. This allows us to cross-compile the code to run on the board:</p> <pre><code>make\nmake install\n</code></pre> <p>Due to the <code>install</code> option defined in the Makefile, the resulting binary is stored in <code>./install_artifact/usr/local/bin</code>. Copy this binary file to a USB flash drive.</p>"},{"location":"Dashboard%20Display/Dev%20Guide/developer-package/#transferring","title":"Transferring","text":"<p>Tip</p> <p>This example transfers files using a simple USB flash drive. If the device is connected to a network, Linux commands such as <code>scp</code> may also work. </p> <p>Connect the USB flash drive into the stm32MP1. If your host device is connected to the device's ST-Link through a Minicom session, you will see the USB flash drive detected.</p> <p></p> <p>Warning</p> <p>Errors were experienced when using a USB flash drive formatted to use an Ex-FAT file system. However, FAT32 seemed to work just fine.</p> <p>Success</p> <p>Notice that the following steps have a terminal prompt of <code>root@stm32mp1:~#</code>. This is to indicate that the command is intended to be entered on the target device's terminal.</p> <p>Mount the contents of the USB flash drive to a mounting point:</p> <ul> <li>In the above screenshot of the output, you see that <code>sda1</code> is assigned to <code>sda</code>. This is subject to change. You may see <code>sda2</code> or even <code>sba1</code>.</li> </ul> <pre><code>root@stm32mp1:~# mount /dev/sda1 /mnt\n</code></pre> <p>Copy the binary file from the USB flash drive to local storage:</p> <pre><code>root@stm32mp1:~# cp /mnt/temp/hello_world_example /usr/local\n</code></pre> <p>Refresh:</p> <pre><code>root@stm32mp1:~# sync\n</code></pre>"},{"location":"Dashboard%20Display/Dev%20Guide/developer-package/#run","title":"Run","text":"<p>Mark the binary file as an executable and run.</p> <pre><code>root@stm32mp1:~# cd /usr/local\nroot@stm32mp1:~# chmod +x hello_world_example\nroot@stm32mp1:~# ./hello_world_example\n</code></pre> <p>If successful, you will see the following output from the application:</p> <p></p>"},{"location":"Dashboard%20Display/Dev%20Guide/os-flashing-tools/","title":"OS Flashing Tools","text":""},{"location":"Dashboard%20Display/Dev%20Guide/os-flashing-tools/#cubeprogrammer","title":"CubeProgrammer","text":"<p>This tool will be used for partitioning an SD card to support a Linux distribution. </p> <ul> <li>Download the installer on stm32CubeProgrammer.</li> <li>This also includes the stm32CubeCLT (Command Line Tool) internally.</li> <li>Run the installer (the file ending with <code>.linux</code>) and accept all default options.</li> <li>To use the executable icon to launch the program, right-click it and select <code>Allow Launching</code>.</li> <li>Running the executable should successfully yield the following window:</li> </ul> <p></p>"},{"location":"Dashboard%20Display/Dev%20Guide/os-flashing-tools/#cubeclt","title":"CubeCLT","text":"<p>This tool will allow CubeProgrammer to automate tasks for you, such as partioning the SD card for the file system.</p> <p>Add the CLT to your environment paths. Open the file that runs everytime a Linux terminal is booted.</p> <pre><code>nano .bashrc\n</code></pre> <p>At the bottom of the file, add the following line to add the binaries to your paths. Then, save and close the file.</p> <p>Tip</p> <p>When using <code>nano</code> to edit the file, press <code>ctrl+o</code> followed by <code>enter</code> to write to the file, then <code>ctrl+x</code> to exit.</p> <pre><code>export PATH=$HOME/STMicroelectronics/STM32Cube/STM32CubeProgrammer/bin:$PATH\n</code></pre> <p>Test that the following command works in a new terminal session:</p> <pre><code>STM32_Programmer_CLI --h\n</code></pre> <p>If successful, you should expect the following output:</p> <p></p>"},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/","title":"Running Qt5 Apps","text":"<p>Previously, the Starter Package installed OpenSTLinux and prepared the SD card. Then, the Developer Package taught us how to cross-compile a program to run it on the target device. This was done by using a pre-built SDK made by ST. They had built that SDK using Yocto and it is intended for OpenSTLinux, which is also built using Yocto.</p> <p>Here, we are going to leverage ST's Distribution Package. We are essentially using Yocto and OpenEmbedded along with ST's meta-layer to build a custom Linux distro. This will allow us to pre-package the Qt5 framework into the custom Linux image. That is, the stm32mp1 device should already have Qt5 installed to run GUI apps after flashing the SD card.</p> <ul> <li>Reference.</li> <li>Example Article.</li> </ul> <p>Info</p> <p>Be aware of Yocto's Official Documentation, and be mindful of the version being covered on its pages.</p> <p>Warning</p> <p>Up to this point, it is highly recommended to develop on a native Linux machine. Build times will be incredibly long and demand a lot of storage/memory.</p>"},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/#installing-yocto-and-dependencies","title":"Installing Yocto and Dependencies","text":""},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/#install-repo","title":"Install Repo","text":"<pre><code>  sudo apt-get update\n  sudo apt-get install repo\n</code></pre> <p>Verify:</p> <pre><code>repo version\n</code></pre>"},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/#packages-required-by-openembeddedyocto","title":"Packages Required by OpenEmbedded/Yocto","text":"<pre><code>sudo apt-get install gawk wget git diffstat unzip texinfo gcc-multilib  chrpath socat cpio python3 python3-pip python3-pexpect \n</code></pre> <pre><code>sudo apt-get install xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm bsdmainutils\n</code></pre> <pre><code>sudo apt-get install libssl-dev libgmp-dev libmpc-dev lz4 zstd\n</code></pre>"},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/#useful-packages-and-tools","title":"Useful Packages and Tools","text":"<pre><code>sudo apt-get install build-essential libncurses-dev libyaml-dev libssl-dev \n</code></pre> <pre><code>sudo apt-get install coreutils bsdmainutils sed curl bc lrzsz corkscrew cvs subversion mercurial nfs-common nfs-kernel-server libarchive-zip-perl dos2unix texi2html libxml2-utils\n</code></pre>"},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/#yocto-required-packages-for-the-buildhost","title":"Yocto-Required Packages for the Buildhost","text":"<p>The following are required according to the System Requirements section 1.4:</p> <pre><code>sudo apt install gawk wget git diffstat unzip texinfo gcc build-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev python3-subunit mesa-common-dev zstd liblz4-tool file locales\nsudo locale-gen en_US.UTF-8\n</code></pre>"},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/#setting-up-the-custom-linux-image","title":"Setting Up the Custom Linux Image","text":"<p>Create your working directory:</p> <pre><code>mkdir distribution-package\ncd distribution-package\n</code></pre>"},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/#download-and-initialize-the-repo-manifest","title":"Download and Initialize the Repo Manifest","text":"<p>It is common practice for vendors to have a repository referred to as the Repo Manifest. This sets up the Yocto build system for supported products</p> <p>Note that the <code>repo init</code> command is pointing to tags from ST's manifest repository. Also note that this repository's <code>default.xml</code> file is listing other layers to download.</p> <pre><code>repo init -u https://github.com/STMicroelectronics/oe-manifest.git -b refs/tags/[latest tag]\n</code></pre> <pre><code>repo init -u https://github.com/STMicroelectronics/oe-manifest.git -b refs/tags/openstlinux-6.1-yocto-mickledore-mp1-v23.11.15\nrepo sync\n</code></pre> <p></p> <p>Info</p> <p>For information about the resulting <code>distribution-package/</code> directory, see Installing the OpenSTLinux Distribution.</p>"},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/#initializing-the-openembedded-oe-build-environment","title":"Initializing the OpenEmbedded (OE) Build Environment","text":"<p>Accept terms and agreeements.</p> <p>Available <code>DISTRO</code> and <code>MACHINE</code> variables are shown in the OpenSTLinux distribution page.</p> <p>This command enables the build environment, and creates the <code>build.../</code> folder.</p> <pre><code>DISTRO=openstlinux-eglfs MACHINE=stm32mp1 source layers/meta-st/scripts/envsetup.sh\n</code></pre> <p></p> <p></p> <p>Tip</p> <p>If the build process in the Build the Image or Building the SDK sections suddenly shut the terminal mid-process without any indication, your host machine's resources may be overloaded. To get your host machine to successfully finish the build, you may want to limit the amount of threads and the amount of threads performing the <code>do_compile</code> task of each recipe in each layer.</p> <p>Inside the <code>build.../</code> folder, there is a <code>conf/local.conf</code> file. Open the file and write the following at the bottom:</p> <pre><code>PARALLEL_MAKE = \"-j 10\"\nBB_NUMBER_THREADS = \"10\"\n</code></pre>"},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/#build-the-image","title":"Build the Image","text":"<p>Warning</p> <p>Be sure to set aside plenty of time for <code>bitbake</code> commands. On my personal host machine, a successful session of this section took about 5 hours to complete.</p> <pre><code>bitbake [image]\n</code></pre> <pre><code>bitbake st-example-image-qt\n</code></pre> <p></p> <p>Failure</p> <p>Some packages may fail to build. So, use <code>bitbake --continue st-example-image-qt</code> to keep building despite an error with a package. All of the failed packages will be listed in the output when the command finally finishes. Then, do the following for each failed package:</p> <pre><code>bitbake -c cleanall [failed_package]\nbitbake [failed_package]\n</code></pre> <p>Do this manually for all the failed packages, and then re-run <code>bitbake --continue st-example-image-qt</code>.</p> <p>Tip</p> <p>For more flags to the <code>bitbake</code> command, see bitbake tasks that work with the <code>bitbake -c [task]</code> command.</p>"},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/#flashing-the-board-with-the-new-linux-image","title":"Flashing the Board with the New Linux Image","text":"<p>Follow the same process as described in the Starter Package for flashing the board with STM32CubeProgrammer.</p> <p>The <code>.tsv</code> file is located in the following directory:</p> <p><code>distribution-package/build-openstlinuxeglfs-stm32mp1/tmp-glibc/deploy/images/stm32mp1/flashlayout_st-example-image-qt/extensible</code></p> <p>Notice that the subfolder is named <code>/build-[image]-[machine]/</code> based on our <code>IMAGE</code> and <code>MACHINE</code> variables when setting the build environment.</p> <p>Using the <code>ll</code> command here will yield the following contents:</p> <p></p> <p>Select the <code>.tsv</code> that is appropriate for your board.</p> <p>As for selecting the Binaries path on STM32CubeProgrammer, select the following directory: <code>distribution-package/build-openstlinuxeglfs-stm32mp1/tmp-glibc/deploy/images/stm32mp1</code></p> <p>Using <code>ll</code> yields the following contents. Note that there is so many files, that the screenshot below does not show everything.</p> <p></p>"},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/#running-pre-packaged-example-apps","title":"Running Pre-Packaged Example Apps","text":"<p>These applications are already cross-compiled to run on our particular embedded device. They were included in the custom Linux image.</p> <ul> <li>Set both BOOT switches to <code>1</code></li> <li>Insert the flashed Micro-SD card</li> <li>Connect to the display</li> <li>Connect to the internet via Ethernet cable</li> <li>Power on</li> </ul> <p>You will see a still \"OpenSTLinux\" splash screen that does not do anything other than display the image.</p> <p>On the PC, login to the device terminal. To do so, see the Terminal and Serial page.</p> <p>Now, remove the splash screen:</p> <pre><code>psplash-drm-quit\n</code></pre> <p>The screen should be blank now, with nothing to display.</p> <pre><code>cd /usr/share/examples/\n</code></pre> <p>Here, there are plenty of examples in folders/sub-folders with their respective executable. For instance,</p> <pre><code>cd opengl/hellowindow\n./hellowindow\n</code></pre> <p>The screen should now display a 3D \"Qt\" object rotating.</p>"},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/#setting-up-the-custom-sdk","title":"Setting up the Custom SDK","text":"<p>We have a custom Linux distro successfully running on the target device. Now, suppose that we want to run our own application on this custom distro. We must first build our own SDK based on the custom image to cross-compile the application.</p>"},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/#build-the-sdk","title":"Build the SDK","text":"<p>Warning</p> <p>Be sure to set aside plenty of time for bitbake commands. On my personal host machine, a successful session of this section took about 5 hours to complete after reducing the amount of threads and tasks that are allowed to run.</p> <p>Source your environment again and return to your <code>build/...</code> folder. Run the following command:</p> <pre><code>bitbake --continue st-example-image-qt -c populate_sdk\n</code></pre> <p>Failure</p> <p>Note that this command brought issues unless it ran completely without interruption. If an error occurs (such as the terminal crashing due to lack of memory, or the <code>gcc-crosssdk</code> recipe not being found as shown below), manually delete the <code>build/...</code> folder and repeat the process.</p> <p></p> <p>Due to the <code>--continue</code> flag, the final output will include a list of packages/recipes that failed to compile -- if any, at all. To fix this, clean and build each package manually before re-runnig <code>populate_sdk</code>.</p> <pre><code>bitbake -c cleansstate [recipe]\nbitbake [recipe]\n</code></pre> <p>The newly generated SDK can be found in the following directory: <code>tmp-glibc/deploy/sdk</code>.</p>"},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/#installing-qt5","title":"Installing Qt5","text":"<p>First, install the Qt Creator IDE by visiting the Qt for Open Source Development. Scroll down and select the Qt Online Installer. This will include the most up-to-date version of Qt. At the time of this writing, that would be version 6. However, the Repo Manifest used here refers to the <code>meta-qt5</code> layer, not Qt6. </p> <p>Install Qt5:</p> <pre><code>sudo apt install -y qtcreator qtbase5-dev qt5-qmake cmake\n</code></pre> <p>Install examples and the necessary packages to make them viewable on Qt Creator:</p> <pre><code>sudo apt-get install qtbase5-examples qtbase5-doc-html\nsudo apt install -y qtquickcontrols2-5-examples qt5-doc qt5-doc-html qml-module-qtquick-controls2\n</code></pre> <p>Install Qt Creator's preferred compiler:</p> <pre><code>sudo apt install clang\n</code></pre> <p>Next, we must configure Qt Creator to find the directory path to your Qt5 installation. Specifically, we need Qt's flavor of CMake, <code>qmake</code>. You may be able to find it in <code>/lib/qt5/bin/qmake</code>.</p> <p>Warning</p> <p>As of Qt6 and going forward, CMake will be officially preferred over QMake.</p> <p>Go to Preferences &gt; Kits &gt; Qt Versions tab &gt; Add the path.</p> <p></p> <p>Next, we want to add a Kit. This is similar to having different build-profiles.</p> <p>Go to Preferences &gt; Kits &gt; Kits tab &gt; Add to create a kit. Be sure to specify the Qt version.</p> <p></p> <p>When you open Qt Creator, you should be able to see examples for Qt 5 after you toggle the version within the drop-down selector in the top-left corner.</p> <p></p> <p>You are welcome to select any of these example projects to display on the board. For instance, the Chart Example worked sucessfully. Just be sure that you can compile and run the GUI application on your host machine.</p>"},{"location":"Dashboard%20Display/Dev%20Guide/running-qt5-apps/#displaying-a-qt5-application","title":"Displaying a Qt5 Application","text":"<p>Finally, we are going to leverage our custom SDK to cross-compile our GUI app. This will be following steps similar to that of the Developer Package: Installing the SDK section.</p> <p>At the root location of the <code>distribution-package/</code> folder, create an <code>SDK/</code> folder.</p> <p>Recall that you can find the installation script for the custom SDK in the following path:</p> <pre><code>cd build-openstlinuxeglfs-stm32mp1/tmp-glibc/deploy/sdk/\n</code></pre> <p></p> <p>Mark the script installer to run as an executable:</p> <pre><code>chmod +x st-example-image-qt-openstlinux-___-snapshot.sh\n</code></pre> <p>Run the installer and store the SDK in <code>SDK/</code>:</p> <pre><code>./st-example-image-qt-openstlinux-___-snapshot.sh -d ./../../../../SDK/\n</code></pre> <p></p> <p>Source the installer:</p> <pre><code>source SDK/environment-setup-cortexa7t2hf-neon-vfpv4-ostl-linux-gnueabi\n</code></pre> <p>Now, move to the project directory of the Qt project you intend to run. Compile:</p> <pre><code>qmake &amp;&amp; make\n</code></pre> <p>You will find a newly created executable in the same directory. This is what you need to transfer and run on target device. From here, you can follow the same steps for transferring and running a user-space application.</p> <p>Remember to kill the OpenSTLinux splashscreen to see your app displayed on the screen: <pre><code>psplash-drm-quit\n</code></pre></p>"},{"location":"Dashboard%20Display/Dev%20Guide/starter-package/","title":"Starter Package","text":""},{"location":"Dashboard%20Display/Dev%20Guide/starter-package/#overview","title":"Overview","text":"<p>This article is ideal for new developers to test their development board and familiarize with tools available through the Linux terminal. See ST's page on the difference between the stm32MPU Embedded Software Packages.</p> <p>In short:</p> <ul> <li>Starter Package: Provides a demo launcher with example programs.</li> <li>Developer Package: Allows the developer to build applications based on the Linux kernel and uses OpenEmbedded/Yocto for you. This relies on the OpenSTLinux distro.</li> <li>Distribution Package: The developer uses OpenEmbedded/Yocto to build their own distro and can include other open source or 3rd party tools.</li> </ul> <p>Running the Starter Package also installs the OpenSTLinux image on the board and sets the paritions on the SD card for the file system. This must be done for any new SD card being used by the stm32mp1 device.</p>"},{"location":"Dashboard%20Display/Dev%20Guide/starter-package/#usb-serial-link","title":"USB Serial Link","text":"<p>Install libusb:</p> <pre><code>sudo apt-get install libusb-1.0-0\n</code></pre> <p>Move into the following CubeProgrammer folder:</p> <pre><code>cd $HOME/cd STMicroelectronics/STM32Cube/STM32CubeProgrammer/Drivers/rules/\n</code></pre> <p>Allow STM32CubeProgrammer to access the USB port:</p> <pre><code>sudo cp *.* /etc/udev/rules.d/\n</code></pre>"},{"location":"Dashboard%20Display/Dev%20Guide/starter-package/#download-the-image","title":"Download the Image","text":"<p>Here, I will assume your workspace is inside a folder named <code>dev</code>.</p> <pre><code>cd $HOME/dev\n</code></pre> <ul> <li>Download the starter package from ST's website.</li> <li>Move the compressed download to your <code>dev</code> folder.</li> </ul> <p>Uncompress:</p> <pre><code>tar xvf en.flash-stm32mp1-openstlinux-6.1-yocto-mickledore-mp1-v23.06.21.tar.gz\n</code></pre>"},{"location":"Dashboard%20Display/Dev%20Guide/starter-package/#flash-the-image-to-the-sd-card","title":"Flash the Image to the SD Card","text":"<p>Follow the rest of ST's ST's instructions, starting on section 6 Populate the SD Card.</p> <p>This Starter Package page has more in-depth information. </p> <p>Once you flash the SD card, connect an HDMI cable to an external screen and press the RESET button on the board. You should be able to see the OS splash screen and desktop after a couple minutes.</p> <p>This is the process for installing any OS image to the stm32mp1 device.</p> <p>Tip</p> <p>Other Linux-capable devices will require a similar process. Here, ST provides us tools to flash and partition the SD card. Other vendors may or may not require you to manually do this using Linux commands or other tools.</p>"},{"location":"Dashboard%20Display/Dev%20Guide/terminal-and-serial/","title":"Terminal and Serial Output","text":""},{"location":"Dashboard%20Display/Dev%20Guide/terminal-and-serial/#accessing-the-terminal","title":"Accessing the Terminal","text":""},{"location":"Dashboard%20Display/Dev%20Guide/terminal-and-serial/#connecting-via-tty","title":"Connecting via TTY","text":"<p>Connect your host PC to the board's micro-USB port. This is a virtual port serving as a terminal. The board does this by connecting to a TTY.</p> <p>Info</p> <p>You can find more background info on TTYs and Linux here:</p> <ul> <li>What is TTY in Linux?</li> <li>PTY vs TTY</li> </ul> <p>Install <code>minicom</code>:</p> <pre><code>sudo apt-get install minicom\n</code></pre> <ul> <li>The board has two TTY sessions.</li> <li><code>ttyS0</code> corresponds to standard UART.</li> <li><code>ttyACM0</code> corresponds to the STLink interface.</li> </ul> <p>Connect to the STLink interface through the board's TTY file:</p> <pre><code>sudo minicom -D /dev/ttyACM0\n</code></pre> <p>Tip</p> <p>If <code>ttyACM0</code> is not the correct file, check the files in the <code>/dev/</code> directory before and after the board's micro-USB is plugged in to detect the correct file.</p> <p>By default, STLink is running with a baud rate of 115200. <code>minicom</code> also has this baud rate by default. But, if configuring the settings is ever necessary, do so using the <code>sudo minicom -s</code> command.</p> <p>Press the RESET button, and you will see serial output containing bootup information.</p> <p></p> <p>Press Enter and you will be given a terminal prompt looking something like <code>root@stm32mp1:~#</code> where you can run some commands.</p> <p></p> <p>For more information on the board's TTY, check ST's How to Use TTY with User Terminal page.</p>"},{"location":"Dashboard%20Display/Dev%20Guide/terminal-and-serial/#connecting-via-ssh","title":"Connecting via SSH","text":"<ul> <li>Ensure the device is connected to a network through Ethernet or a wireless receiver.</li> <li>Determine the device's assigned IP address.</li> </ul> <p>Remotely access the device: <pre><code>ssh root@[ip address]\n</code></pre></p> <p>Here, <code>root</code> is used as there are no default user accounts on the custom Linux image.</p>"},{"location":"Dashboard%20Display/Dev%20Guide/terminal-and-serial/#reading-serial-output","title":"Reading Serial Output","text":"<p>Follow a process similar to the one described in Connecting via TTY. This time, connect to <code>ttyS0</code>.</p>"},{"location":"Data%20Acquisition/","title":"Data Acquisition (DAQ) System","text":"<p>Project Repository </p> <p>Library API Docs </p>"},{"location":"Data%20Acquisition/#objective","title":"Objective","text":"<ul> <li>A Data Acquisition (DAQ) System for interfacing with the vehicle ECU and additional sensors.</li> <li>Build the first fully-fledged DAQ with re-usable code through:<ul> <li>The Layered Architecture design pattern</li> <li>Modularity of components</li> <li>Hardware abstraction</li> </ul> </li> <li>Efficiently record data to a CSV file for system testing &amp; refinement of other vehicle components via analyses.</li> <li>Make sensor data conveniently accessible for the whole DFR organization.</li> <li>To be used in tandem with DFR's DataAnalyzer.</li> </ul>"},{"location":"Data%20Acquisition/#hardware-and-equipment","title":"Hardware and Equipment","text":""},{"location":"Data%20Acquisition/#target-device","title":"Target Device","text":"<p>The STM32 Nucleo F429ZI microcontroller development board is used as the current target device for code merged to the <code>main</code> and <code>develop</code> branches. Theoretically, other Arm Cortex M4 based STM32 devices with the necessary peripherals should be able to run the same program.</p> <p> </p>"},{"location":"Data%20Acquisition/#firmware-tech-stack","title":"Firmware Tech Stack","text":""},{"location":"Data%20Acquisition/#board-support-package-bsp","title":"Board Support Package (BSP)","text":"<ul> <li>STM32 Hardware Abstraction Layer (HAL)<ul> <li>Generated by STM32CubeMX within the CubeIDE environment, which also provides the <code>arm-none-eabi</code> toolchain.</li> <li>Serves as a set of low-level drivers to interface with the microcontroller.</li> </ul> </li> </ul>"},{"location":"Data%20Acquisition/#real-time","title":"Real-Time","text":"<ul> <li>FreeRTOS<ul> <li>A framework that offers multi-threading and concurrent programming.</li> <li>For optimizing timing and performance.</li> </ul> </li> </ul> <ul> <li>CMSIS-RTOS v2<ul> <li>Not to be mistaken for another RTOS framework.</li> <li>An abstraction layer for interacting with an RTOS framework (i.e., FreeRTOS).</li> </ul> </li> </ul>"},{"location":"Data%20Acquisition/#file-system","title":"File System","text":"<ul> <li>FatFS<ul> <li>A library for creating files accessible through the FAT file system.</li> <li>Allows end users to access the resulting CSV file on any device.</li> </ul> </li> </ul>"},{"location":"Data%20Acquisition/#devops-and-automation","title":"DevOps and Automation","text":""},{"location":"Data%20Acquisition/#unit-tests","title":"Unit Tests","text":"<ul> <li>Google Test<ul> <li>A framework for writing unit tests.</li> <li>Developed and ran on the developer's host device.</li> <li>Compiled and ran using CMake with Ninja.</li> </ul> </li> </ul>"},{"location":"Data%20Acquisition/#api-docs","title":"API Docs","text":"<ul> <li>Our API documentation is built using a combination of three tools:<ul> <li>Doxygen \u2014 A traditional tool generating documentation pages by scanning the C/C++ source code.</li> <li>Sphinx \u2014 A modernized, more aesthetic documentation tool.</li> <li>Breathe \u2014 A project that bridges and connects Doxygen and Sphinx</li> </ul> </li> </ul>"},{"location":"Data%20Acquisition/#environments","title":"Environments","text":"<ul> <li>Docker<ul> <li>For building containerized environments with dependencies pre-installed.</li> <li>Utilized for locally writing unit tests and API documentation.</li> </ul> </li> </ul>"},{"location":"Data%20Acquisition/#cicd-pipeline","title":"CI/CD Pipeline","text":"<p>Coming soon...</p>"},{"location":"Data%20Acquisition/Application/Data%20Logger/circular_queue/","title":"Circular Queue","text":""},{"location":"Data%20Acquisition/Application/Data%20Logger/circular_queue/#description","title":"Description","text":"<ul> <li>Functions as a regular queue.</li> <li>When full, the next new entry overwrites the oldest entry.</li> <li>Implemented with C++ generics to support any data type.</li> <li>The following functionalities are supported:<ul> <li>Inserting</li> <li>Removing</li> <li>Checking whether it is empty or full</li> <li>Clearing</li> <li>Locking and unlocking an internal mutex</li> </ul> </li> </ul>"},{"location":"Data%20Acquisition/Application/Data%20Logger/circular_queue/#firmware-component-library","title":"Firmware Component Library","text":"<p>Library API Docs </p> <p>Source Code </p> <p>Info</p> <p>This is a common data structure. You can find plenty of information online, such as GeeksForGeek's Introduction to Circular Queue.</p> <p>Example</p> <p>Creating a circular queue of integers.</p> <pre><code>#include \"../DFR_Libraries/Application/circular_queue.hpp\"\n\nint main() {\n    int size = 5;\n    pplication::CircularQueue&lt;int&gt; queue(size);\n\n    queue.Enqueue(8);\n    queue.Enqueue(2);\n    queue.Enqueue(11);\n    queue.Enqueue(9);\n    queue.Enqueue(4);\n\n    if (queue.IsFull()) {\n        printf(\"Queue is full!\\n\");\n    }\n\n    // Overwrite entry of number 8\n    queue.Enqueue(33);\n\n    return 0;\n}\n</code></pre> <p>Example</p> <p>Creating a circular queue of <code>DataPayload</code>s.</p> <pre><code>#include \"../DFR_Libraries/Application/circular_queue.hpp\"\n#include \"../DFR_Libraries/Application/data_payload.hpp\"\n\nint main() {\n    int size = 5;\n    pplication::CircularQueue&lt;application::DataPayload&gt; queue(size);\n\n    DataPayload data;\n    data.timestamp_ = 2.0f;\n\n    // Insert a copy of the data payload at this instant\n    queue.Enqueue(data);\n\n    if (!queue.IsEmpty()) {\n        // Receive from the queue\n        DataPayload data = queue.Dequeue();\n        printf(\"Timestamp: %f\\n\", data.timestamp_);\n    }\n\n    return 0;\n}\n</code></pre> <p>The <code>CircularQueue</code> also has an additional constructor for accepting a mutex, if this were to be used as a shared component among threads in an RTOS environment.</p> <p>Example</p> <p>Sharing a circular queue between threads using FreeRTOS through CMSIS-RTOS v2.</p> <p>Assume that the Kernel is already initialized and running.</p> <pre><code>#include \"../DFR_Libraries/Application/circular_queue.hpp\"\n#include \"../DFR_Libraries/Application/data_payload.hpp\"\n\nconst osMutexAttr_t queue_mutex_attributes = {\n    \"myThreadMutex\",\n    osMutexRecursive | osMutexPrioInherit,\n    NULL,\n    0U\n};\n\nauto mutex = std::make_shared&lt;application::MutexCmsisV2&gt;(queue_mutex_attributes);\n\nint size = 5;\napplication::CircularQueue&lt;int&gt; queue(size, mutex);\n\nvoid ProducerThread() {\n    int num = 2;\n\n    for(;;) {\n        num *= 2;\n\n        queue.Lock();\n        queue.Enqueue(num);\n        queue.Unlock();\n    }\n}\n\nvoid ConsumerThread() {\n    for(;;) {\n        queue.Lock();\n        int received_num = queue.Dequeue();\n        queue.Unlock();\n\n        printf(\"Received: %d\\n\", received_num);\n    }\n}\n</code></pre>"},{"location":"Data%20Acquisition/Application/Data%20Logger/data_logger/","title":"Data Logger","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Application/Data%20Logger/data_logger/#details","title":"Details","text":"<ul> <li>Integrates the following support logging to a CSV file:<ul> <li>Writing and storing files</li> <li>User input toggling</li> <li>Receiving data from a queue</li> </ul> </li> <li>Observes whether the storage unit is connected or ejected.</li> <li>Shares a status indicator of whether it is currently logging. </li> </ul>"},{"location":"Data%20Acquisition/Application/Data%20Logger/data_logger/#firmware-component-library","title":"Firmware Component Library","text":"<p>Library API Docs </p> <p>Source Code </p> <pre><code>classDiagram\n\ndirection TB\n\nnamespace ApplicationLayer {\n    class DataLogger {\n        +Run()\n\n        -CreateCsvFile()\n        -FindUniqueFileName()\n        -RecordDataSample(): bool\n        -SetState()\n    }\n\n    class IFileSystem {\n        &lt;&lt;interface&gt;&gt;\n\n        +Mount() bool\n        +Unmont() bool\n        +FileExists() bool\n        +CreateFile() bool\n        +OpenFile() bool\n        +CloseFile() bool\n        +WriteFile() bool\n        +ReadFile() bool\n        +CreateDirectory() bool\n    }\n\n    class CircularQueue {\n        +Enqueue()\n        +Dequeue() Generic_T\n        +IsEmpty() bool\n        +IsFull() bool\n        +Clear()\n        +Lock()\n        +Unlock()\n    }\n\n    class DataPayload {\n        +GetCsvFormatLength() int\n        +CsvFormat()\n        +Lock()\n        +Unlock()\n    }\n}\n\nnamespace PlatformLayer {\n    class IGpio {\n        &lt;&lt;interface&gt;&gt;\n\n        +Read() bool\n        +Write()\n        +ToggleDetected() bool\n    }\n}\n\nDataLogger --&gt; IFileSystem\nDataLogger --&gt; CircularQueue\nDataLogger --&gt; DataPayload\nDataLogger --&gt; IGpio\n\nend</code></pre>"},{"location":"Data%20Acquisition/Application/Data%20Logger/data_logger/#how-to-use","title":"How to Use","text":"<p>Be sure to provide all the dependencies:</p> <ul> <li>Any implementation of the IFileSystem interface, for managing files and block device mounting.</li> <li>Any implementation of the IGpio interface, for reading a user's input to toggle data logging.</li> <li>The CircularQueue and DataPayload for receiving data as an input.</li> <li>A boolean that allows for observing whether the storage unit is connected or ejected.</li> <li>A boolean for sharing whether we are currently logging.</li> </ul> <p>Example</p> <p>Using the <code>DataLogger</code>.</p> <pre><code>int cppMain() {\n    // Initialize DataLogger object\n    DataLogger data_logger(...);\n\n    for(;;) {\n        data_logger.Run();\n    }\n}\n</code></pre> <p>That is it! This library is kept simple to use due to the internal state machine. To get a full explanation on how to integrate the dependencies, go to the Current Implementation section.</p>"},{"location":"Data%20Acquisition/Application/Data%20Logger/data_logger/#state-machine","title":"State Machine","text":"<p>Internally, the <code>DataLogger</code> has the following states defined:</p> <ul> <li><code>Idle</code></li> <li><code>Standby</code></li> <li><code>Logging</code></li> </ul> <p>This approach was taken to handle multiple cases due to the state of the storage unit being connected/ejected and providing the user control over when to log data.</p> <p>This was implemented by using abstraction and inheritance. Each state inherits from <code>State()</code>, which defines that each state must have actions when entering, computing/executing, and exiting.</p> <p>The <code>DataLogger</code> then has a private <code>SetState()</code> method for defining what happens at transitions:</p> <ul> <li>Perform exit actions.</li> <li>Change states.</li> <li>Perform entry actions.</li> </ul> <p>Defining exit and entry actions ensures that something is performed only once, which can be beneficial for simplifying logic. No need to dedicate a boolean variable to indicate whether a particular action has been performed!</p> <p>Info</p> <p>You can find a simple, minimalist example of implementing a state machine in this article: Implementing a Finite State Machine in C++ by Aleksandr Hovhannisyan.</p> <p>Note that in this article, instances of each state is created using a static method. In favor of a more idiomatic approach, we simply declared an instance of each state as a private variable.</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Idle\n    Idle --&gt; Standby : Storage connected\n\n    Standby --&gt; Idle : Storage ejected\n    Standby --&gt; Logging : User switch enabled\n\n    Logging --&gt; Standby : User switch disabled\n    Logging --&gt; Idle : Storage ejected</code></pre>"},{"location":"Data%20Acquisition/Application/Data%20Logger/data_logger/#idle-state","title":"Idle State","text":"<p>The default state at bootup. That is, entry actions does not occur when the device is booted.</p> <ul> <li>Entry: Unmount the file system.</li> <li>When the storage unit is connected, transition to the <code>Standby</code> state.</li> <li>Exit: Mount the file system.</li> </ul>"},{"location":"Data%20Acquisition/Application/Data%20Logger/data_logger/#standby-state","title":"Standby State","text":"<ul> <li>When the storage unit is ejected, transition to the <code>Idle</code> state.</li> <li>When the user toggles the loging switch, and the switch's state is <code>HIGH</code>, then logging is enabled and transition to the <code>Logging</code> state.</li> </ul>"},{"location":"Data%20Acquisition/Application/Data%20Logger/data_logger/#logging-state","title":"Logging State","text":"<ul> <li>Entry:<ul> <li>Create and open a new CSV file with a unique name</li> <li>Clear the queue.</li> </ul> </li> <li>When the storage unit is ejected, transition to the <code>Idle</code> state.</li> <li>When the user toggles the loging switch, and the switch's state is <code>LOW</code>, then logging is disabled and transition to the <code>Standby</code> state.</li> <li>If the queue is not empty, grab an instance of the data payload and record it to the CSV file.</li> <li>Exit: Close the CSV file.</li> </ul>"},{"location":"Data%20Acquisition/Application/Data%20Logger/data_logger/#current-implementation","title":"Current Implementation","text":""},{"location":"Data%20Acquisition/Application/Data%20Logger/data_logger/#file-system","title":"File System","text":"<p>Our FatFs wrapper fulfills the requirements of the <code>IFileSystem</code> interface. USB is used for our storage unit, so be sure to enable the following CubeMX settings described in that page's USB in a Baremetal Environment and USB in an RTOS Environment sections.</p> <p>Thanks to our state machine, we only need one boolean variable to observe whether a USB flash drive is connected or ejected. Note that in C, there is no <code>bool</code> type, so we settle for using <code>uint8_t</code>.</p> <p>In <code>USB_HOST/App/usb_host.c</code>:</p> <pre><code>/* USER CODE BEGIN Includes */\nuint8_t usb_connected_observer = 0;\n\nstatic void USBH_UserProcess  (USBH_HandleTypeDef *phost, uint8_t id)\n{\n  /* USER CODE BEGIN CALL_BACK_1 */\n  switch(id)\n  {\n  case HOST_USER_SELECT_CONFIGURATION:\n  break;\n\n  case HOST_USER_DISCONNECTION:\n  Appli_state = APPLICATION_DISCONNECT;\n  usb_connected_observer = 0; // Set to false\n  break;\n\n  case HOST_USER_CLASS_ACTIVE:\n  Appli_state = APPLICATION_READY;\n  usb_connected_observer = 1; // Set to true\n  break;\n\n  case HOST_USER_CONNECTION:\n  Appli_state = APPLICATION_START;\n  break;\n\n  default:\n  break;\n  }\n  /* USER CODE END CALL_BACK_1 */\n}\n</code></pre> <p>Then, expose this global variable in other files as necessary:</p> <pre><code>#include \"usb_host.h\"\nextern uint8_t usb_connected_observer;\n</code></pre> <p>This variable will be used for initializing the <code>DataLogger</code>.</p>"},{"location":"Data%20Acquisition/Application/Data%20Logger/data_logger/#user-interrupt-signal","title":"User Interrupt Signal","text":"<p>To provide the user the ability to toggle data logging, we leverage an interrupt signal. This is more power efficient and responsive than polling. A switch is preferrable over a push-button for two reasons:</p> <ul> <li>Enabling/disabling is visually noticeable to the user.</li> <li>No need to handle button de-bouncing in neither the hardware or firmware.</li> </ul> <p>To enable a GPIO pin as an interrupt, enable the pin for GPIO_EXTIx on CubeMX. Do not enable it as a GPIO_Input \u2014 that is for polling operations. Then, enable the interrupt signal in the NVIC interrupt table.</p> <p></p> <p></p> <p>Then, configure when the interrupt signal will occur. Note that these interrupt signals can be very sensitive. So, the <code>DataLogger</code> uses a strategy of being notified when the switch is toggled. When toggled, the <code>DataLogger</code> will poll the GPIO pin to confirm whether the state is <code>HIGH</code> or <code>LOW</code>. This helps toggling to be far less sporadic and unstable.</p> <p></p>"},{"location":"Data%20Acquisition/Application/Data%20Logger/data_logger/#integrating","title":"Integrating","text":"<p>The <code>CircularQueue</code> and <code>DataPayload</code> are simple to provide to the <code>DataLogger</code>. Lastly, we just need to define a boolean variable for the <code>DataLogger</code> to internally update, according to whether it is logging.</p> <p>Example</p> <p>Integrating <code>DataLogger</code> with <code>FatFs</code> to write to a USB.</p> <pre><code>// 3rd Party Libraryes and Frameworks\n#include \"fatfs.h\"\nextern char USBHPath[4];   // USBH logical drive path\nextern FATFS USBHFatFS;    // File system object for USBH logical drive\nextern FIL USBHFile;       // File object for USBH\n\n#include \"usb_host.h\"\nextern uint8_t usb_connected_observer; // USB connected/ejected interrupt\n\n// DFR Custom Dependencies\n#include \"../DFR_Libraries/Application/circular_queue.hpp\"\n#include \"../DFR_Libraries/Application/data_payload.hpp\"\n#include \"../DFR_Libraries/Application/DataLogger/DataLogger.hpp\"\n#include \"../DFR_Libraries/Application/FileSystem/fat_fs.hpp\"\n#include \"../DFR_Libraries/Platform/Interfaces/igpio.hpp\"\n#include \"../DFR_Libraries/Platform/STM/F4/GPIO/gpio_stmf4.hpp\"\n\nstd::shared_ptr&lt;platform::GpioStmF4&gt; gpio_callback_ptr(nullptr);\n\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {\n    gpio_callback_ptr-&gt;InterruptCallback(GPIO_Pin);\n}\n\n\nvoid DataLoggingThread() {\n    MX_USB_HOST_Init();\n\n    auto file_system = std::make_shared&lt;application::FatFs&gt;(USBHPath, USBHFatFS, USBHFile);\n\n    auto toggle_switch = std::make_shared&lt;platform::GpioStmF4&gt;(GPIOF, GPIO_PIN_15);\n    gpio_callback_ptr = toggle_switch;\n\n    application::CircularQueue&lt;application::DataPayload&gt; queue(size);\n\n    application::DataPayload data_payload;\n\n    bool is_logging_flag = false;\n\n    application::DataLogger data_logger(file_system,\n                                        toggle_switch,\n                                        queue,\n                                        usb_connected_observer,\n                                        is_logging_flag);\n\n    for (;;) {\n        data_logger.Run();\n        osDelay(1000);\n\n        if (is_logging_flag) {\n            printf(\"Logging...\\n\");\n        }\n        else {\n            printf(\"Either in Standby or Idle state...\\n\");\n        }\n    }\n}\n</code></pre>"},{"location":"Data%20Acquisition/Application/Data%20Logger/data_payload/","title":"Data Payload","text":""},{"location":"Data%20Acquisition/Application/Data%20Logger/data_payload/#description","title":"Description","text":"<ul> <li>A simple struct that collects data across the DAQ.</li> <li>A centralized point of providing newly updated data.</li> <li>Converts all fields to a null-terminated string in the CSV format.</li> <li>Provides what the length of the string may be. This is useful for dynamically allocating a buffer before converting the data to a string. A size is necessary when creating the buffer.</li> <li>Has an additional constructor for accepting a mutex if to be used as a shared component among threads.</li> </ul> <p>Library API Docs </p> <p>Source Code </p>"},{"location":"Data%20Acquisition/Application/File%20System/","title":"Accelerometer","text":""},{"location":"Data%20Acquisition/Application/File%20System/#description","title":"Description","text":"<ul> <li>Mounting and unmounting of the physical storage media.</li> <li>Opening/closing files with different permission modes.</li> <li>Writing to a file.</li> <li>Seeking for a file in a directory.</li> </ul>"},{"location":"Data%20Acquisition/Application/File%20System/#supported-implementations","title":"Supported Implementations","text":"<pre><code>classDiagram\n\nnamespace ApplicationLayer {\n    class IFileSystem {\n        &lt;&lt;interface&gt;&gt; \n    }\n\n    class FatFs { }\n}\n\nIFileSystem &lt;-- FatFs\n\nlink FatFs \"fat_fs/\"\n\nend</code></pre>"},{"location":"Data%20Acquisition/Application/File%20System/#additional-features","title":"Additional Features","text":""},{"location":"Data%20Acquisition/Application/File%20System/#posix-compliant-flags","title":"POSIX-Compliant Flags","text":"<p>In the spirit of making this interface agnostic, POSIX-compliant flags are defined for supporting a consistent manner of opening files. For instance, to open a file in read-only mode, one may use something like `file_system.FileOpen(\"r\");</p> <pre><code>// POSIX compliant mode flags\nstatic constexpr char* kReadOnlyMode               = (char*)\"r\";\nstatic constexpr char* kReadWriteMode              = (char*)\"r+\";\nstatic constexpr char* kEmtpyFileAndWriteMode      = (char*)\"w\";\nstatic constexpr char* kEmptyFileAndReadWriteMode  = (char*)\"w+\";\nstatic constexpr char* kAppendFileAndWriteMode     = (char*)\"a\";\nstatic constexpr char* kAppendFileAndReadWriteMode = (char*)\"a+\";\nstatic constexpr char* kNewFileAndWriteMode        = (char*)\"wx\";\nstatic constexpr char* kNewFileAndReadWriteMode    = (char*)\"w+x\";\n</code></pre>"},{"location":"Data%20Acquisition/Application/File%20System/#error-setting","title":"Error Setting","text":"<p>The following bitfields are defined and can be used by an implementation to support easier debugging of file system operations.</p> <pre><code>enum class ErrorFlags : uint16_t {\n    Mounting        = 1 &lt;&lt; 0,\n    Unmounting      = 1 &lt;&lt; 1,\n    FileNotFound    = 1 &lt;&lt; 2,\n    CreateFile      = 1 &lt;&lt; 3,\n    OpenFile        = 1 &lt;&lt; 4,\n    ReadFile        = 1 &lt;&lt; 5,\n    WriteFile       = 1 &lt;&lt; 6,\n    CloseFile       = 1 &lt;&lt; 7,\n    CreateDirectory = 1 &lt;&lt; 8\n};\n\nstatic constexpr uint8_t kNumErrorFlags = 9;\nunsigned int errors_ : kNumErrorFlags;\n\nvoid SetError(ErrorFlags flag) {\n    errors_ |= static_cast&lt;uint16_t&gt;(flag);\n}\n\nunsigned int GetError(ErrorFlags flag) {\n    return errors_ &amp; static_cast&lt;uint16_t&gt;(flag);\n}\n</code></pre>"},{"location":"Data%20Acquisition/Application/File%20System/fat_fs/","title":"Fat FS","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Application/File%20System/fat_fs/#details","title":"Details","text":"<ul> <li>A wrapper class based on ChaN's FatFS module.</li> <li>Compatible with USB OTG (On the Go) and SDIO communication protocols.</li> <li>Additional information can be found in ST's USB Host Library User Manual<sup>1</sup>.</li> </ul> Fat FS API interactions. USB Host library interactions."},{"location":"Data%20Acquisition/Application/File%20System/fat_fs/#cubemx-platform-integrations","title":"CubeMX Platform Integrations","text":"<p>Integrating the library with the CubeMX settings is discussed first as this impacts how the device connecting/ejecting is to be synchronized with the library's usage.</p>"},{"location":"Data%20Acquisition/Application/File%20System/fat_fs/#usb-in-a-baremetal-environment","title":"USB in a Baremetal Environment","text":"<p>ControllersTech's STM32 USB Host MSC article and video are great references for enabling logging to a USB flash drive.</p> <p>The following peripherals and libraries need to be made on CubeMX:</p> <ul> <li>USB OTG FS (Full Speed)</li> <li>Enable USB HOST</li> <li>FatFS Library</li> </ul> <p>USB OTG FS communicates at 12 Mbps. Set its Mode to operate in <code>Host_Only</code>, and activate the 5 Volt <code>VBus</code> line to power the USB flash drive. Leave the Parameter Settings, User Constants, NVIC Settings, and GPIO Settings to their default values.</p> <p> </p> USB OTF Full Speed configurations. <p>USB HOST's Class for FS IP should be set to <code>Mass Storage Host Class</code>. Go to the Platfom Settings tab and verify that Drive_VBUS_FS is configured to with <code>GPIO:Output</code> set to the pin responsible for providing the VBus line. This varies per microcontroller and can be verified by observing the board's schematics. For instance, on the Nucleo F429ZI development board, pin <code>PG6</code> is responsible for powering the USB (that is, VBUS).</p> <p> </p> USB Host configurations. <p> </p> USB Port and VBus schematic for Nucleo F429ZI. <p>If done correctly, the <code>LD7</code> LED light on the Nucleo F429ZI should be lit when running the program. This confirms that the board is providing power to the USB flash drive. <sup>2</sup></p> <p> </p> Nucleo F429ZI's VBus LED light. <p>Success</p> <p>For reference, the schematics can be downloaded from the dev board's Product Page under <code>CAD Resources &gt; Schematic Pack &gt; Schematics</code>. After extracting the folder, a PDF of the schematics is contained inside the folder.</p> <p>Lastly, enable FATFS to operate in the <code>USB Disk</code> mode, enable Long File Naming (USE_LFN), set Maximum Sector Size (MAX_SS) to <code>4096</code>, and enable the exFAT file system (FS_EXFAT) for portability across user devices.</p> <p> </p> FATFS configurations. <p>Saving your CubeMX <code>.ioc</code> configurations for auto-generating the code will add the <code>FATFS/</code> and <code>USB_HOST/</code> folder \u2014 resulting in the following project structure:</p> <pre><code>CubeIDE Project/\n|-- Core/\n|-- Drivers/\n|-- FATFS/\n|-- Middlewares/\n|-- USB_HOST/\n</code></pre> <p>Following ControllersTech's STM32 USB Host MSC demonstration, there are pieces of code to be aware of. First, the USB Host is updated periodically, in <code>main.c</code>:</p> <pre><code>int main(void) {\n    HAL_Init();\n    SystemClock_Config();\n\n    MX_FATFS_Init();\n    MX_USB_HOST_Init();\n\n    while (1) {\n        MX_USB_HOST_Process();\n    }\n}\n</code></pre> <p><code>MX_USB_HOST_Process()</code> is a helper function for calling <code>USBH_Process()</code>, in <code>USB_HOST/App/usb_host.c</code>. The application code can be placed in this file instead of in the main function, and defines a switch statement that behaves like a state machine with interrupts handled by the USB Host library:</p> <pre><code>static void USBH_UserProcess  (USBH_HandleTypeDef *phost, uint8_t id)\n{\n  /* USER CODE BEGIN CALL_BACK_1 */\n  switch(id)\n  {\n  case HOST_USER_SELECT_CONFIGURATION:\n  break;\n\n  case HOST_USER_DISCONNECTION:\n  Appli_state = APPLICATION_DISCONNECT;\n  // Unmount the USB device for ejection here.\n  break;\n\n  case HOST_USER_CLASS_ACTIVE:\n  Appli_state = APPLICATION_READY;\n  // Mount the USB device and perform operations here.\n  break;\n\n  case HOST_USER_CONNECTION:\n  Appli_state = APPLICATION_START;\n  break;\n\n  default:\n  break;\n  }\n  /* USER CODE END CALL_BACK_1 */\n}\n</code></pre> <p>The <code>HOST_USER_DISCONNECTION</code> case is executed when the USB is physically disconnected and the <code>HOST_USER_CLASS_ACTIVE</code> case is executed when the USB is physically connected.</p> <p>This solution works for a brute-forced solution in a C environment, but how can we leverage our C++ library with this? Adding C++ code such as namespaces or classes to <code>usb_host.c</code> will not work because this is automatically configured by CubeIDE to be compiled with the C compiler. This obsticle applies to the other auto-generated files and folders. This has driven us to add <code>Program/</code> folder to the CubeIDE project and enabled the C++ compiler to point to it. With C (USB state machine) and C++ (our custom libraries) in separate directories, they need a solution for synchronization. For a proof of concept, boolean variables are sufficient.</p> <p>In <code>USB_HOST/App/usb_host.c</code>:</p> <pre><code>/* USER CODE BEGIN Includes */\nuint8_t to_log = 0;\nuint8_t to_unmount = 0;\n\nstatic void USBH_UserProcess  (USBH_HandleTypeDef *phost, uint8_t id)\n{\n  /* USER CODE BEGIN CALL_BACK_1 */\n  switch(id)\n  {\n  case HOST_USER_SELECT_CONFIGURATION:\n  break;\n\n  case HOST_USER_DISCONNECTION:\n  Appli_state = APPLICATION_DISCONNECT;\n  to_unmount = 1; // Set the unmounting flag\n  break;\n\n  case HOST_USER_CLASS_ACTIVE:\n  Appli_state = APPLICATION_READY;\n  to_log = 1; // Set the logging flag\n  break;\n\n  case HOST_USER_CONNECTION:\n  Appli_state = APPLICATION_START;\n  break;\n\n  default:\n  break;\n  }\n  /* USER CODE END CALL_BACK_1 */\n}\n</code></pre> <p>In <code>Program/Src/app.cpp</code>:</p> <pre><code>// 3rd Party Libraryes and Frameworks\n#include \"fatfs.h\"\nextern char USBHPath[4];   // USBH logical drive path\nextern FATFS USBHFatFS;    // File system object for USBH logical drive\nextern FIL USBHFile;       // File object for USBH\n#include \"usb_host.h\"\n\nint cppMain() {\n    MX_USB_HOST_Init();\n\n    // Initialize our FatFs wrapper class\n    application::FatFs file_system(USBHPath, USBHFatFS, USBHFile);\n\n    for (;;) {\n        if(to_log == 1) {\n            printf(\"Logging to USB\\n\");\n            file_system.Mount();\n\n            // Perform operations\n\n            to_log = 0;\n\n        } else if (to_unmount == 1) {\n            file_system.Unmount();\n            to_unmount = 0;\n            printf(\"USB ejected\\n\");\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Data%20Acquisition/Application/File%20System/fat_fs/#usb-in-an-rtos-environment","title":"USB in an RTOS Environment","text":"<p>Enabling FreeRTOS on CubeMX will cause some of the USB peripheral code to be generated slightly differently. If you check the USB Host's Parameter Settings, an additional CMSIS_RTOS category of configurable fields have appeared at the bottom.</p> <p> </p> USB Host configurations with FreeRTOS. <p>These settings reveal that CubeMX is generating code for initializing another thread behind the scenes. Examining the generated firmware closely has led to the <code>Middlewares/ST/STM32_USB_Host_library/Core/Src/usbh_core.c</code> file. This defines a function <code>USBH_Process_OS()</code> that calls <code>USBH_Process()</code> in a <code>USBH_Thread</code> thread \u2014 provided that the USBH_USE_OS field of the USB Host's Parameter Settings is enabled.</p> <p>In <code>Middlewares/ST/STM32_USB_Host_library/Core/Src/usbh_core.c</code>:</p> <pre><code>#if (USBH_USE_OS == 1U)\n#if (osCMSIS &lt; 0x20000U)\n\n  /* Create USB Host Queue */\n  osMessageQDef(USBH_Queue, MSGQUEUE_OBJECTS, uint16_t);\n  phost-&gt;os_event = osMessageCreate(osMessageQ(USBH_Queue), NULL);\n\n  /* Create USB Host Task */\n#if defined (USBH_PROCESS_STACK_SIZE)\n  osThreadDef(USBH_Thread, USBH_Process_OS, USBH_PROCESS_PRIO, 0U, USBH_PROCESS_STACK_SIZE);\n#else\n  osThreadDef(USBH_Thread, USBH_Process_OS, USBH_PROCESS_PRIO, 0U, 8U * configMINIMAL_STACK_SIZE);\n#endif /* defined (USBH_PROCESS_STACK_SIZE) */\n\n  phost-&gt;thread = osThreadCreate(osThread(USBH_Thread), phost);\n\n// ...\n\n#if (osCMSIS &lt; 0x20000U)\nstatic void USBH_Process_OS(void const *argument)\n{\n  osEvent event;\n\n  for (;;)\n  {\n    event = osMessageGet(((USBH_HandleTypeDef *)argument)-&gt;os_event, osWaitForever);\n    if (event.status == osEventMessage)\n    {\n      USBH_Process((USBH_HandleTypeDef *)argument);\n    }\n  }\n}\n#endif\n</code></pre> <p>Recall that  <code>USBH_Process()</code> was called through the <code>MX_USB_HOST_Process()</code> helper function in the USB in a Baremetal Environment section. The helper function was manually called in the superloop. Now, with FreeRTOS enabled, this is instead handled by the <code>USBH_Thread</code> thread and is not exposed to us.</p> <p>However, to make this thread functional, it is vitally important to increase the stack size to 1024. This can be done by setting the USBH_PROCESS_STACK_SIZE to <code>1024 Words</code>, as shown in the configuration image above. By default, this is set to only 128.</p> <p>Tip</p> <p>It may be helpful to re-test the firmware immediately after modifying thread properties, such as stack size. Insufficient memory allocated to a thread will cause the microcontroller to suddenly context-switch to a Hard Fault handler, where it is stuck in an infinite loop. While step-debugging, you can see that this may occur at any moment. Simply increase the stack size until the thread can run reliably for multiple iterations.</p> <p>Moving on, since the USB Host leverages interrupts to update its state machine, additional configurations are required to make it functional with FreeRTOS. In the NVIC settings, the Preemption Priority column of the USB On The Go FS global interrupt field is set to <code>15</code>. This lowers the priority of the USB's interrupt so that it does not conflict with other pre-existing system interrupts.</p> <p>Tip</p> <p>A lower preemption priority corresponds to a logically higher numerical value. The higher the value, the lower the priority. Thus, the USB's interrupt was changed from a default value of 5 to the lowest support value of 15.</p> <p> </p> Configuring USB's global interrupt on the NVIC settings. <p>Warning</p> <p>Allowing CubeMX to generate code with these new configurations yields the following warning:</p> <p></p> <p>As of now, this has not raised any noticeable issues.</p> <p>Lastly, we must configure the hardware interrupt signals to work with RTOS by adding <code>NVIC_SetPriorityGrouping( 0 );</code> right before the RTOS Kernel is initialized and started.</p> <p>Warning</p> <p>Omitting <code>NVIC_SetPriorityGrouping( 0 );</code> will cause the microcontroller to get stuck in the following code at line 770 of the <code>port.c</code> file:</p> <pre><code>#if( configASSERT_DEFINED == 1 )\n\n  void vPortValidateInterruptPriority( void )\n  {\n  uint32_t ulCurrentInterrupt;\n  uint8_t ucCurrentPriority;\n\n  /* Obtain the number of the currently executing interrupt. */\n  __asm volatile( \"mrs %0, ipsr\" : \"=r\"( ulCurrentInterrupt ) :: \"memory\" );\n\n  /* Is the interrupt number a user defined interrupt? */\n  if( ulCurrentInterrupt &gt;= portFIRST_USER_INTERRUPT_NUMBER )\n  {\n    /* Look up the interrupt's priority. */\n    ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];\n\n    /* The following assertion will fail if a service routine (ISR) for\n    an interrupt that has been assigned a priority above\n    configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API\n    function.  ISR safe FreeRTOS API functions must *only* be called\n    from interrupts that have been assigned a priority at or below\n    configMAX_SYSCALL_INTERRUPT_PRIORITY.\n\n    Numerically low interrupt priority numbers represent logically high\n    interrupt priorities, therefore the priority of the interrupt must\n    be set to a value equal to or numerically *higher* than\n    configMAX_SYSCALL_INTERRUPT_PRIORITY.\n\n    Interrupts that   use the FreeRTOS API must not be left at their\n    default priority of   zero as that is the highest possible priority,\n    which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,\n    and   therefore also guaranteed to be invalid.\n\n    FreeRTOS maintains separate thread and ISR API functions to ensure\n    interrupt entry is as fast and simple as possible.\n\n    The following links provide detailed information:\n    http://www.freertos.org/RTOS-Cortex-M3-M4.html\n    http://www.freertos.org/FAQHelp.html */\n    configASSERT( ucCurrentPriority &gt;= ucMaxSysCallPriority );\n  }\n\n  /* Priority grouping:  The interrupt controller (NVIC) allows the bits\n  that define each interrupt's priority to be split between bits that\n  define the interrupt's pre-emption priority bits and bits that define\n  the interrupt's sub-priority.  For simplicity all bits must be defined\n  to be pre-emption priority bits.  The following assertion will fail if\n  this is not the case (if some bits represent a sub-priority).\n\n  If the application only uses CMSIS libraries for interrupt\n  configuration then the correct setting can be achieved on all Cortex-M\n  devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the\n  scheduler.  Note however that some vendor specific peripheral libraries\n  assume a non-zero priority group setting, in which cases using a value\n  of zero will result in unpredictable behaviour. */\n  configASSERT( ( portAIRCR_REG &amp; portPRIORITY_GROUP_MASK ) &lt;= ulMaxPRIGROUPValue );\n}\n\n#endif /* configASSERT_DEFINED */\n</code></pre> <p>The global boolean variables for synchronizing our application code with the USB's interrupts described in the USB in a Baremetal Environment section still applies. Finally, we can initialize our own thread to make use of the USB flash drive.</p> <pre><code>// 3rd Party Libraryes and Frameworks\n#include \"cmsis_os.h\"\n#include \"fatfs.h\"\nextern char USBHPath[4];   /* USBH logical drive path */\nextern FATFS USBHFatFS;    /* File system object for USBH logical drive */\nextern FIL USBHFile;       /* File object for USBH */\n#include \"usb_host.h\"\n\n// DFR Custom Dependencies\n#include \"app.hpp\"\n#include \"Application/FileSystem/fat_fs.hpp\"\n\nosThreadId_t dataLoggingTaskHandle;\nconst osThreadAttr_t dataLoggingTask_attributes = {\n  .name = \"dataLoggingTask\",\n  .stack_size = 128 * 17,\n  .priority = (osPriority_t) osPriorityNormal,\n};\n\nvoid RtosInit() {\n    dataLoggingTaskHandle = osThreadNew(DataLoggingThread, NULL, &amp;dataLoggingTask_attributes);\n}\n\nint cppMain() {\n    NVIC_SetPriorityGrouping( 0 );\n    osKernelInitialize();   // Initialize scheduler\n    RtosInit();             // Initialize thread\n    osKernelStart();        // Start scheduler\n\n    // The remaining code in this function is never reached as it is overtaken by the kernel.\n    // The threads are running instead.\n\n    for(;;) {\n\n    }\n\n    return 0;\n}\n\nvoid DataLoggingThread(void *argument) {\n    MX_USB_HOST_Init();\n\n    // Initialize our FatFs wrapper class\n    application::FatFs file_system(USBHPath, USBHFatFS, USBHFile);\n\n    for (;;) {\n        if(to_log == 1) {\n            printf(\"Logging to USB\\n\");\n            file_system.Mount();\n\n            // Perform operations\n\n            to_log = 0;\n\n        } else if (to_unmount == 1) {\n            file_system.Unmount();\n            to_unmount = 0;\n            printf(\"USB ejected\\n\");\n        }\n    }\n\n    return 0;\n}\n</code></pre> <p>Here, two threads are running:</p> <ul> <li>The hidden <code>USBH_Thread</code>, and</li> <li>Our <code>DataLoggingThread</code>.</li> </ul>"},{"location":"Data%20Acquisition/Application/File%20System/fat_fs/#sdio","title":"SDIO","text":"<p>Theoretically, our <code>FatFs</code> wrapper class should be functional for logging to a micro-SD card using through the SDIO communication protocol. </p> <p>Recall that the USB implementation leverages externally defined variables. These are defined by the FATFS library.</p> <p>Defined in <code>fatfs.c</code>:</p> <pre><code>#include \"fatfs.h\"\n\nuint8_t retUSBH;    /* Return value for USBH */\nchar USBHPath[4];   /* USBH logical drive path */\nFATFS USBHFatFS;    /* File system object for USBH logical drive */\nFIL USBHFile;       /* File object for USBH */\n</code></pre> <p>Exposed in <code>fatfs.h</code>: and defined in <code>fatfs.c</code>:</p> <pre><code>extern uint8_t retUSBH; /* Return value for USBH */\nextern char USBHPath[4]; /* USBH logical drive path */\nextern FATFS USBHFatFS; /* File system object for USBH logical drive */\nextern FIL USBHFile; /* File object for USBH */\n</code></pre> <p>Used inn our <code>Program/Src/app.cpp</code>:</p> <pre><code>#include \"fatfs.h\"\nextern char USBHPath[4];   /* USBH logical drive path */\nextern FATFS USBHFatFS;    /* File system object for USBH logical drive */\nextern FIL USBHFile;       /* File object for USBH */\n\napplication::FatFs file_system(USBHPath, USBHFatFS, USBHFile);\n</code></pre> <p>However, unlike with the USB implementation, the variables expected to be passed to the constructor may have to be manually defined. This is the justification for expecting these parameters to be passed via the constructor instead of being internally hidden. It is up to the consumer of this library to provide these necessary inputs.</p> <p>If SDIO is ever to be re-implemented, ControllersTech's Interface SD Card with SDIO article and video may be a great reference.</p>"},{"location":"Data%20Acquisition/Application/File%20System/fat_fs/#hardware","title":"Hardware","text":"<p>Device Primary Guide </p> <p></p> <ul> <li>Device: SDIO Breakout Board by Adafruit.</li> </ul>"},{"location":"Data%20Acquisition/Application/File%20System/fat_fs/#pinout","title":"Pinout","text":"Nucleo F446RE Breakout Board PC8 DAT0 PC9 DAT1 PC10 DAT2 PC11 DAT3 PC12 CLK PD2 CMD PB6 CD (Card Detection)"},{"location":"Data%20Acquisition/Application/File%20System/fat_fs/#firmware-component-library","title":"Firmware Component Library","text":"<p>Library API Docs </p> <p>Source Code </p> <pre><code>classDiagram\ndirection TB\nnamespace ApplicationLayer {\n    class IFileSystem {\n        &lt;&lt;interface&gt;&gt;\n        -kReadOnlyMode: char*               = \"r\"\n        -kReadWriteMode: char*              = \"r+\"\n        -kEmtpyFileAndWriteMode: char*      = \"w\"\n        -kEmptyFileAndReadWriteMode: char*  = \"w+\"\n        -kAppendFileAndWriteMode: char*     = \"a\"\n        -kAppendFileAndReadWriteMode: char* = \"a+\"\n        -kNewFileAndWriteMode: char*        = \"wx\"\n        -kNewFileAndReadWriteMode: char*    = \"w+x\"\n\n        -ErrorFlags : uint16_t\n        -kNumErrorFlags: uint8_t = 9\n        -errors_: int = kNumErrorFlags\n\n        -SetError()\n        -GetError() unsigned int\n\n        +Mount() bool\n        +Unmont() bool\n        +FileExists() bool\n        +CreateFile() bool\n        +OpenFile() bool\n        +CloseFile() bool\n        +WriteFile() bool\n        +ReadFile() bool\n        +CreateDirectory() bool\n    }\n    class FatFs{\n        -kReadOnlyMode: char*               = \"r\"\n        -kReadWriteMode: char*              = \"r+\"\n        -kEmtpyFileAndWriteMode: char*      = \"w\"\n        -kEmptyFileAndReadWriteMode: char*  = \"w+\"\n        -kAppendFileAndWriteMode: char*     = \"a\"\n        -kAppendFileAndReadWriteMode: char* = \"a+\"\n        -kNewFileAndWriteMode: char*        = \"wx\"\n        -kNewFileAndReadWriteMode: char*    = \"w+x\"\n\n        -ErrorFlags : uint16_t\n        -kNumErrorFlags: uint8_t = 9\n        -errors_: int = kNumErrorFlags\n\n        -SetError()\n        -GetError() unsigned int\n\n        -kMaxDrivePathLength: uint8_t = 4\n        -kForceMount: BYTE = 1\n\n        -FileDoesNotExist() bool\n        -EvaluateResult() bool\n\n        +Mount() bool\n        +Unmont() bool\n        +FileExists() bool\n        +CreateFile() bool\n        +OpenFile() bool\n        +CloseFile() bool\n        +WriteFile() bool\n        +ReadFile() bool\n        +CreateDirectory() bool\n\n    }\n}\n\nIFileSystem &lt;-- FatFs\nend</code></pre>"},{"location":"Data%20Acquisition/Application/File%20System/fat_fs/#how-to-use","title":"How to Use","text":"<p>Before beginning operations on files and directories, it is important to mount the block device onto the file system. Also, before ejecting the block device, it must be unmounted.</p> <p>Example</p> <p>Mounting the block device before beginning file/directory operations.</p> <pre><code>int cppMain() {\n    MX_USB_HOST_Init();\n    application::FatFs file_system(USBHPath, USBHFatFS, USBHFile);\n    file_system.Mount();\n\n    // Perform file/directory operations\n\n    file_system.Unmount();\n    return 0;\n}\n</code></pre> <p>Files and directories can be created in any format to suite the user, provided that the file path is maintained. </p> <p>Example</p> <p>Creating folders and sub-directories.</p> <pre><code>int cppMain() {\n    MX_USB_HOST_Init();\n    application::FatFs file_system(USBHPath, USBHFatFS, USBHFile);\n    file_system.Mount();\n\n    char dir1_path[] = \"/DIR1\";\n    file_system.CreateDirectory(dir1_path);\n\n    char dir_file_path[] = \"/DIR1/file1.txt\";\n    file_system.CreateFile(root_file_path);\n\n    char subdir1_path[] = \"/DIR1/SUBDIR1\";\n    file_system.CreateDirectory(subdir1_path);\n\n    char subdir_file_path[] = \"/DIR1/SUBDIR1/file2.txt\";\n    file_system.CreateFile(root_file_path);\n\n    file_system-&gt;Unmount();\n    return 0;\n}\n</code></pre> <p>This result in the following file directory tree:</p> <pre><code>Block device logical drive\n|-- DIR1/\n    |-- file1.txt\n    |-- SUBDIR1/\n        |-- file2.txt\n</code></pre> <p>To interact with a file, it must first be opened. Then, it must be closed when finished.</p> <p>Example</p> <p>Writing to a file.</p> <pre><code>int cppMain() {\n    MX_USB_HOST_Init();\n    application::FatFs file_system(USBHPath, USBHFatFS, USBHFile);\n    file_system.Mount();\n\n    char root_file_path[] = \"/ROOTFILE.txt\";\n    file_system.CreateFile(root_file_path);\n    file_system.OpenFile(root_file_path, (char*)\"a\");\n    file_system.WriteFile((char*)\"Hello World\");\n    file_system.CloseFile();\n\n    file_sytem.Unmount();\n    return 0;\n}\n</code></pre> <p>To understand why the <code>\"a\"</code> flag is provided as an argument to <code>OpenFile()</code>, see the POSIX-Compliant Flags section.</p> <p>It is possible to search for a file and determine whether it exists. Similar to the other functions, <code>FileExists()</code> provides a return status for the consumer of the library to handle appropriately for their specific use case.</p> <p>Example</p> <p>Checking whether a specific file exists.</p> <pre><code>int cppMain() {\n    MX_USB_HOST_Init();\n    application::FatFs file_system(USBHPath, USBHFatFS, USBHFile);\n    file_system.Mount();\n\n    bool is_found = file_system.FileExists((char*)\"/ROOTFILE.txt\");\n\n    file_system.Unmount();\n    return 0;\n}\n</code></pre> <p>Example</p> <p>Reading content from a file.</p> <pre><code>int cppMain() {\n    MX_USB_HOST_Init();\n    application::FatFs file_system(USBHPath, USBHFatFS, USBHFile);\n    file_system.Mount();\n\n    uint8_t max_buffer_size = 10;\n    char buffer[max_buffer_size];\n    bool status = file_system.ReadFile(buffer);\n\n    if (status) {\n        printf(buffer);\n    } else {\n        printf((char*)\"Reading failed!\");\n    }\n\n    file_system.Unmount();\n    return 0;\n}\n</code></pre> <p>Here, we initialize a buffer capable of holding up to 10 characters.</p> <p>Any file type is supported. To write to a CSV file, the column entries are separated with a comma <code>,</code> and row entries are separated with a new line <code>\\n</code>.</p> <p>Example</p> <p>Using the <code>IFileSystem</code> abstract interface to interact with <code>FatFs</code> to create and write a CSV file.</p> <pre><code>int cppMain() {\n    MX_USB_HOST_Init();\n    std::unique_ptr&lt;application::IFileSystem&gt; file_system(nullptr);\n    file_system = std::make_unique&lt;application::FatFs&gt;(USBHPath, USBHFatFS, USBHFile);\n    file_system-&gt;Mount();\n\n    char root_file_path[] = \"/ROOTFILE.csv\";\n    file_system-&gt;CreateFile(root_file_path);\n\n    char root_file_header_row[] = \"LinPot1,LinPot2,AccX,AccY,AccZ\\n\";\n    char root_file_contents[] = \"2.3,2.45,2,9,200\\n\";\n    file_system-&gt;OpenFile(root_file_path, (char*)\"a\");\n    file_system-&gt;WriteFile(root_file_header_row);\n    file_system-&gt;WriteFile(root_file_contents);\n    file_system-&gt;WriteFile(root_file_contents);\n    file_system-&gt;CloseFile();\n\n    file_system-&gt;Unmount();\n    return 0;\n}\n</code></pre> <p>The <code>ROOTFILE.csv</code> file will contain the following:</p> Linpot1 Linpot2 AccX AccY AccZ 2.3 2.45 2 9 200 2.3 2.45 2 9 200"},{"location":"Data%20Acquisition/Application/File%20System/fat_fs/#posix-compliant-flags","title":"POSIX-Compliant Flags","text":"<p>The <code>FileOpen()</code> method requires a valid POSIX-compliance flag for determining the access mode in which the file is to be opened with. This serves to translate between the common POSIX standard and the Fat FS byte flags <sup>3</sup>.</p> POSIX Fat FS <code>\"r\"</code> <code>FA_READ</code> <code>\"r+\"</code> <code>FA_READ</code> <code>FA_WRITE</code> <code>\"w\"</code> <code>FA_CREATE_ALWAYS</code> <code>FA_WRITE</code> <code>\"w+\"</code> <code>FA_CREATE_ALWAYS</code> <code>FA_WRITE</code> <code>FA_READ</code> <code>\"a\"</code> <code>FA_OPEN_APPEND</code> <code>FA_WRITE</code> <code>\"a+\"</code> <code>FA_OPEN_APPEND</code> <code>FA_WRITE</code> <code>FA_READ</code> <code>\"wx\"</code> <code>FA_CREATE_NEW</code> <code>FA_WRITE</code> <code>\"w+x\"</code> <code>FA_CREATE_NEW</code> <code>FA_WRITE</code> <code>FA_READ</code>"},{"location":"Data%20Acquisition/Application/File%20System/fat_fs/#error-setting","title":"Error Setting","text":"<p>Fat FS supports the following status values, defined by <code>FRESULT</code> in their <code>ff.h</code> file.</p> <pre><code>/* File function return code (FRESULT) */\n\ntypedef enum {\n    FR_OK = 0,              /* (0) Succeeded */\n    FR_DISK_ERR,            /* (1) A hard error occurred in the low level disk I/O layer */\n    FR_INT_ERR,             /* (2) Assertion failed */\n    FR_NOT_READY,           /* (3) The physical drive cannot work */\n    FR_NO_FILE,             /* (4) Could not find the file */\n    FR_NO_PATH,             /* (5) Could not find the path */\n    FR_INVALID_NAME,        /* (6) The path name format is invalid */\n    FR_DENIED,              /* (7) Access denied due to prohibited access or directory full */\n    FR_EXIST,               /* (8) Access denied due to prohibited access */\n    FR_INVALID_OBJECT,      /* (9) The file/directory object is invalid */\n    FR_WRITE_PROTECTED,     /* (10) The physical drive is write protected */\n    FR_INVALID_DRIVE,       /* (11) The logical drive number is invalid */\n    FR_NOT_ENABLED,         /* (12) The volume has no work area */\n    FR_NO_FILESYSTEM,       /* (13) There is no valid FAT volume */\n    FR_MKFS_ABORTED,        /* (14) The f_mkfs() aborted due to any problem */\n    FR_TIMEOUT,             /* (15) Could not get a grant to access the volume within defined period */\n    FR_LOCKED,              /* (16) The operation is rejected according to the file sharing policy */\n    FR_NOT_ENOUGH_CORE,     /* (17) LFN working buffer could not be allocated */\n    FR_TOO_MANY_OPEN_FILES, /* (18) Number of open files &gt; _FS_LOCK */\n    FR_INVALID_PARAMETER    /* (19) Given parameter is invalid */\n} FRESULT;\n</code></pre> <p>To abstract this away, while still maintaining error values that provide context of where something may have failed, an enum along with bitfields were defined in the <code>IFileSystem</code> interface.</p> <pre><code>enum class ErrorFlags : uint16_t {\n    Mounting        = 1 &lt;&lt; 0,\n    Unmounting      = 1 &lt;&lt; 1,\n    FileNotFound    = 1 &lt;&lt; 2,\n    CreateFile      = 1 &lt;&lt; 3,\n    OpenFile        = 1 &lt;&lt; 4,\n    ReadFile        = 1 &lt;&lt; 5,\n    WriteFile       = 1 &lt;&lt; 6,\n    CloseFile       = 1 &lt;&lt; 7,\n    CreateDirectory = 1 &lt;&lt; 8\n};\n\nstatic constexpr uint8_t kNumErrorFlags = 9;\nunsigned int errors_ : kNumErrorFlags;\n\nvoid SetError(ErrorFlags flag) {\n    errors_ |= static_cast&lt;uint16_t&gt;(flag);\n}\n\nunsigned int GetError(ErrorFlags flag) {\n    return errors_ &amp; static_cast&lt;uint16_t&gt;(flag);\n}\n</code></pre> <p>This allows <code>SetError()</code> to be utilized by our <code>FatFs</code> wrapper class when evaluating the success/failure of an operation indicated by <code>FRESULT</code> \u2014 a status indicator that is specific to their library.</p> <p>Warning</p> <p>For maintaining the <code>errors_</code> bitfield, the <code>kNumErrorFlags</code> must match with the mount of entries in the <code>ErrorFlags</code> enum. This constant must be updated appropriately if flags are added/removed from <code>ErrorFlags</code>.</p> <ol> <li> <p>ST's USB Host Library user manual.\u00a0\u21a9</p> </li> <li> <p>ST's Nucleo-144 Boards user manual.\u00a0\u21a9</p> </li> <li> <p>The values in the Fat FS columns are combined into a single byte using the bitwise OR <code>|</code> operator.\u00a0\u21a9</p> </li> </ol>"},{"location":"Data%20Acquisition/Application/RTOS%20Components/mutex/","title":"Mutex","text":""},{"location":"Data%20Acquisition/Application/RTOS%20Components/mutex/#description","title":"Description","text":"<ul> <li>Functions as a typical mutex.</li> <li>If the shared resource is not available, the requesting thread is put into a blocked state.</li> <li>Conforms to the <code>IMutex</code> interface to work with the <code>CircularQueue</code> and <code>DataPayload</code>.</li> </ul>"},{"location":"Data%20Acquisition/Application/RTOS%20Components/mutex/#firmware-component-library","title":"Firmware Component Library","text":"<p>Library API Docs </p> <p>Source Code </p> <p>Info</p> <p>This is a common data structure. You can find plenty of information online, such as Shawn Hymel's Introduction to RTOS - Mutex.</p> <p>Warning</p> <p>Note that CMSIS-RTOS V2 wrapper class implementation must be created after calling <code>osKernelInitalize()</code>. For this reason, this implementation has a separate <code>Create()</code> method.</p> <p>Example</p> <p>Creating a mutex.</p> <pre><code>#include \"../DFR_Libraries/Application/Mutex/mutex_cmsisv2.hpp\"\n\nconst osMutexAttr_t mutex_attributes = {\n    \"myThreadMutex\",\n    osMutexRecursive | osMutexPrioInherit,\n    NULL,\n    0U\n};\n\nauto m = std::make_shared&lt;application::MutexCmsisV2&gt;(mutex_attributes);\n\n\nint main() {\n    osKernelInitialize();\n    m-&gt;Create();\n\n    // Request to use resource shared with other thread\n    m-&gt;Lock();\n\n    // ...\n    // Use the shared resource\n\n    // Release the shared resource for other threads to use\n    m-&gt;Unlock();\n\n    return 0;\n}\n</code></pre> <p>For more examples, the firmware currently uses two mutexes to share the <code>CircularQueue</code> and <code>DataPayload</code> among multiple threads.</p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/","title":"List of Custom PCB Boards","text":"<p>This page was last updated: September 3, 2024</p> <p>All PCB projects (schematics, footprints, pcb files, etc.) are stored in a dedicated GitHub repo.</p> <p>DAQ-PCB Repository </p> <p>Custom PCB revisions:</p> <ul> <li>Revision 1</li> </ul>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/","title":"DAQ Revision 1","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#overview","title":"Overview","text":"<p>The first revision of the DAQ is an STM32F4-based board that is designed to extract data from sensors and store them in a CSV format on a USB flash drive or device.</p> <p>The KiCad project files can be found in the <code>Rev1/</code> directory of the DAQ-PCB GitHub repository.</p> <p>DAQ-PCB Rev1 Project </p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#features","title":"Features","text":"<p>The first revision consists of:</p> <ul> <li>Programming and debugging via 10-pin SWD</li> <li>User push-button</li> </ul> Peripheral Quantity CAN 2.0B 2 USB OTG FS 1 GPIO 8 I2C 2 SPI 2 USART 1 ADC 8 <p>This first revision contains multiple outputs to allow for flexibility for sensor choices and for flexibility in functions for the DAQ. </p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#form-factor","title":"Form factor","text":"<p>The size of the board wasn't a major consideration for the board as this first revision was meant to be a test bench for future iterations. Leading a board that is significantly bigger than it needs to be. The board dimensions are 153.0350 by 114.300 mm or 6.025 by 4.5 inches. The board edges are curved for aesthetics as well as it makes the board less jagged around the edges. The board is also fitted with m4 screws in each corner to allow for it to be mounted into an enclosure.</p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#stm32-pcb-essentials","title":"STM32 PCB Essentials","text":"<p>In order to get the STM32-based microcontroller to work a few things must be wired to ensure reliable functionality of the board.</p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#boot0","title":"BOOT0","text":"<p>The microcontroller's <code>BOOT0</code> pin dictates the firmware that runs on the board.</p> <ul> <li>When tied to <code>LOW</code>, the board will run on the firmware that is on its flash memory.</li> <li>When tied to <code>HIGH</code> (that is, <code>VCC</code>), then it will run the system memory program.</li> </ul> <p>However, since the board has SWD connectors the board can be programmed regardless of the state of <code>BOOT0</code></p> <p>Warning</p> <p>From personal experience this has not been the case, but keeping the <code>BOOT0</code> pin tied to <code>GND</code> seems to always work.</p> <p>If programming via USB-to-UART, <code>BOOT0</code> becomes more relevant and you will need to tie it to <code>GND</code> to support the USB-to-UART programming feature. To ensure the functionality of both USB-to-UART and SWD programming, the <code>BOOT0</code> was put into an SPDT switch that changes between <code>GND</code> and <code>VCC</code>.</p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#nrst","title":"NRST","text":"<p><code>NRST</code> is a reset pin tied to a button that can reset the microcontroller when NRST is set to <code>LOW</code>.</p> <p>Danger</p> <p>This pin is not advised to be left floating as that could lead to accidental, spurious resets of the microcontroller. </p> <p>A typical 4-pin button was placed that connects <code>GND</code> and <code>NRST</code>. A 100 nF capacitor is also added between <code>NRST</code> and <code>GND</code> to debounce the switch and ensure that voltage spikes do not accidentally toggle the NRST.</p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#vcap-1-and-vcap-2","title":"VCAP 1 and VCAP 2","text":"<p>These are capacitors that are connected to the internal voltage regulator of the MCU. This voltage regulator is primarily for powering the core and internal components of the MCU. The <code>VCAP</code> pins act as decoupling capacitors for this voltage regulator. Based on stm32 PCB guidelines<sup>1</sup> these values should be around 2.2u capacitors that have a low ESR.</p> <p>Note</p> <p>The actual PCB uses 22 uF. This was a typo when making the schematic, but the board still functions as intended.</p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#pdr","title":"PDR","text":"<p>This pin is used to either enable or disable the Power Down on Reset (PDR).</p> <p>PDR serves as a reset function when the supply voltage drops below a certain threshold level. Typically, this is 3.3 volts. The whole reason for this is to ensure that the microcontroller will only function as intended. Low voltage supplies can make the MCU unpredictable. Otherwise, if left on, the system may behave unpredictably.</p> <ul> <li>When set to <code>HIGH</code>, the PDR features are enabled.</li> <li>When set to <code>LOW</code>, all the features are disabled.</li> </ul>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#vref","title":"Vref","text":"<p>This is the voltage reference used for the built-in ADCs on the board and must be tied into a positive voltage that is relatively clean from noise.</p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#hse","title":"HSE","text":"<p>High-Speed External (HSE) is not required for the board, but is something that most boards will have. The point of this pin is to add an external clock to the microcontroller to ensure a more precise and accurate clock. Note that this external oscillator needs to be within a certain range of frequencies and this differs for each board<sup>2</sup>. The stm32F429 that is used for this DAQ can take an oscillator frequency ranging from 4 to 26 MHz. This value is both available when using the clock configurator in the .IOC file of a STM32CubeIDE project or can be direcly found in the datasheet of the respecitve MCU<sup>3</sup>. </p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#vdd-vdda-vss-vssa-and-decoupling-capacitors","title":"VDD, VDDA, VSS, VSSA, and Decoupling Capacitors","text":"<ul> <li><code>VDD</code> \u2014 the digital voltage supply to power digital devices, such as GPIOs.</li> <li><code>VDDA</code> \u2014 the analog voltage supply to power analog devices, such as ADCs.</li> <li><code>VSS</code> and <code>VSSA</code> \u2014 the respective grounds.</li> </ul> <p>To ensure that the voltage supplied to the microcontroller has relatively low noise levels, decoupling capacitors are used to filter the voltage supply.</p> <p>Success</p> <p>The rule of thumb here is to have 1 decoupling capacitor for each <code>VDD</code>, <code>Vbat</code>, or <code>VDDA</code> pin that is present on the microcontroller.</p> <p><code>VDDA</code> and <code>VDD</code> tend to be filtered a little differently so they tend to require their specific values for filtering. Typically, a 100 nF decoupling capacitor is used for each pin. A 4.7 uF bulk decoupling capacitor is added to the <code>VDD</code> pin and a 1 uF decoupling capacitor is added to the analog pin filtering.</p> <p>Example</p> <p>This DAQ contains 13 VDD pins (this includes <code>Vbat</code>) and 1 VDDA pin. So you would have the following: - Fourteen 100 nF decoupling capacitors - One 4.7 uF bulk decoupling capacitor for <code>VDD</code> - One 1 uF bulk decoupling capacitor for the <code>VDDA</code>.</p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#communication-protocols","title":"Communication Protocols","text":"<p>Info</p> <p>The pinouts for supporting specific communication protocols were selected with CubeMX as a visual aid.</p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#spi","title":"SPI","text":"<p>Two SPI peripherals are supported. These is rather straightforward as the pins are directly connected to the MCU.</p> <p>For the first SPI peripheral (that is, <code>SPI3</code> on CubeMX), the pins are:</p> Microcontroller Pins SPI Functionality PC12 <code>MOSI</code> PC11 <code>MISO</code> PC10 <code>SCK</code> PG9 <code>CS</code> <p>For the second SPI peripheral (that is, <code>SPI5</code> on CubeMX), the pins are:</p> Microcontroller Pins SPI Functionality PF9 <code>MOSI</code> PF8 <code>MISO</code> PF7 <code>SCK</code> PF6 <code>CS</code>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#i2c","title":"I2C","text":"<p>I2C requires a pull-up resistor to function properly. These resistors typically range from 2 Kilo-Ohm to 10 Kilo-Ohms. The values you consider for the pull resistors matter because they influence the speed and frequency you can support for I2C communication. There are specific equations to calculate the range of pull up resistor values available to use but they are based on both the speed of the bus and the bus capacitance. The speed of the bus is a given variable but the bus capacitance is unique to each PCB so can be rather hard to calculate proper pull up resistor values. Since bus capacitance can be a tricky value to obtain during the design stage, a rule of thumb for resistor values is used rather than calculating the specific range of resistor values.</p> <ul> <li>If 100 KHz is fast enough for your applications, then you can use a 10 Kilo-Ohm pull-up resistor.</li> <li>If 400 KHz, then 2 Kilo-Ohm pull-up resistors will be preferable.</li> </ul> <p>Note</p> <p>The larger the value of the pull-up resistor, the smaller the current drawn by the I2C peripheral.</p> <p>This particular revision uses 2.2 Kilo-Ohms so that it can be compatible with both 400 KHz and 100KHz I2C rates.</p> <p>For the first I2C peripheral (that is, <code>I2C1</code> on CubeMX), the pins are:</p> Microcontroller Pins I2C Functionality PB9 <code>SDA</code> PB8 <code>SCL</code> <p>For the second I2C peripheral (that is, <code>I2C2</code> on CubeMX), the pins are:</p> Microcontroller Pins I2C Functionality PF0 <code>SDA</code> PF1 <code>SCL</code>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#can-20b","title":"CAN 2.0B","text":"<p>CAN is a little different compared to I2C or SPI since it requires both a CAN controller and a CAN transceiver. The STM32 F429 has an internal CAN controller, but does not have a CAN transceiver. Here, a TJA1051 CAN transceiver is used.</p> <p>CAN also requires a differential impedance when connecting data from the CAN connector to the CAN transceiver. This impedance should be 120 ohms. In addition, since the DAQ is also going to contain the termination resistor, the differential impedance also has to go through a 120-ohm termination resistor. After the CAN differential traces have reached the CAN transceiver the signal breaks into an Rx and Tx signal which can be routed like a normal trace to the MCU.</p> <p>Note that the CAN transceiver takes 5v rather than 3.3V, so this IC is powered by the USB 5V rather than the 3.3V that powers the MCU.</p> <p>For the first CAN peripheral (that is, <code>CAN1</code> on CubeMX), the pins are:</p> Microcontroller Pins CAN Functionality PD0 <code>CAN Rx</code> PD1 <code>CAN Tx</code> <p>For the second CAN peripheral (that is, <code>CAN2</code> on CubeMX), the pins are:</p> Microcontroller Pins CAN Functionality PB12 <code>CAN Rx</code> PB13 <code>CAN Tx</code>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#usb","title":"USB","text":"<p>This first revision was focused on just getting differential impedance correct for a minimal USB implementation. The USB is directly connected to the <code>USB+</code> and <code>USB-</code> pins on the MCU.</p> <p>The USB was also routed with a 90 differential impedance. This is something that should change in future iterations. For now, this revision serves as a test bench on getting the basic functionality of USB to work properly.</p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#usb-to-usart","title":"USB-to-USART","text":"<p>The board also supports USB-to-UART for debugging and programming purposes. This is supported by using the MCP2200T IC to handle conversion between the two protocols. The MCP2200T also comes with a few GPIO pins that are broken out in the board, but have no plans on being used. This is routed using a 90 ohm differential impedance.</p> <p>For the USART peripheral (that is, <code>USART1</code> on CubeMX), the pins are:</p> Microcontroller Pins USART Functionality PB7 <code>Rx</code> PB6 <code>Tx</code>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#miscellaneous","title":"Miscellaneous","text":""},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#voltage-regulator","title":"Voltage Regulator","text":"<p>AMS1117 is a LDO Voltage regulator with a 3.3V / 1A output. The input is paired with a 10 uF decoupling capacitor and the output has a 22 uF decoupling capacitor. The values for these decoupling capacitors are taken straight from the datasheet of the voltage regulator. In addition, at the output of the voltage regulator, there is a resistor and LED to indicate that the voltage regulator is outputting power. Basically, it is a power LED.</p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#back-voltage-and-back-feeding","title":"Back Voltage and Back Feeding","text":"<p>Since there are multiple USBs that could potentially power the board, Schottky diodes are used to prevent any back voltage or back feeding. All 5V are connected to a plane so when one USB is powered it powers the whole plane. Using a diode in series with the Vbus essentially allows only one USB to power the plane. This occurs because if one USB powers the plane then the diode of the unplugged USB cannot generate the required forward voltage to turn on the diode even when plugged in.</p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#usb-power","title":"USB Power","text":"<p>USB-C is used to supply the board with 5V, which is then fed to the AMS1117 LDO voltage regulator used to convert that 5V to 3.3V for the MCU. Realistically, USB-C could have been used for both USB-to-UART and for power, but I felt it would have been easier to separate them to guarantee they both could function correctly. Future iterations could see them both combined so I could remove 1 USB connector from the board.</p> <p>Note that VBus is coming from the power source. So, it is not necessary to enable the microcontroller's Vbus in CubeMx when configuring the firmware despite the following warning when auto-generating code:</p> <p></p>"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#gpio","title":"GPIO","text":"<p>There are 10 GPIO pins and are pretty straightforward to connect. They go straight from a connector to the pins on the MCU. In order to have more flexibility on where the GPIO connectors go on the board the GPIOs were spit onto 2 separate 5-pin screw terminals. </p> Microcontroller Pins GPIO Numeration PG8 GPIO1 PG7 GPIO2 PG6 GPIO3 PG5 GPIO4 PG4 GPIO5 PG3 GPIO6 PG2 GPIO7 PD15 GPIO8 PD14 GPIO9 PD13 GPIO10"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#analog","title":"Analog","text":"<p>Analog pins are simply connected directly to the MCU and a connector. This revision contains 8 analog pins that are split in half. 4 analog pins are connected to a 6-pin Molex connector. The reason for splitting them is because there was already a use case for 4 of the analog pins which was for the linear potentiometers. For the sake of uniformity, I made 8 analog pins and had the other four go to another Molex connector. Also, 4 of the analog pins are connected to the first ADC, and the other four are connected to the second ADC.</p> <p>For the first ADC peripheral (that is, <code>ADC1</code> on CubeMX), the pins are:</p> Microcontroller Pins ADC Input PC4 IN14 PC5 IN15 PB0 IN8 PB1 IN9 <p>For the second ADC peripheral (that is, <code>ADC2</code> on CubeMX), the pins are:</p> Microcontroller Pins ADC Input PA4 IN4 PA5 IN5 PA6 IN6 PA78 IN7"},{"location":"Data%20Acquisition/Custom%20DAQ%20PCB%20Boards/DAQ%20Revision%201/Revision%201/#bugs","title":"Bugs","text":"<p>The USART peripheral assigned to the UART-USB bridge circuit does not output valid content. Repeatedly \"poking\" the pad of the Rx or Tx pin with a probe had yielded the following results:</p> <p></p> <ol> <li> <p>Application Note: STM32 F4 Hardware Development Guide, STMicroelectronics.\u00a0\u21a9</p> </li> <li> <p>Application Note: HSE Configuration Guide, STMicroelectronics.\u00a0\u21a9</p> </li> <li> <p>STM32F429xx datasheet: HSE input frequencies, STMicroelectronics.\u00a0\u21a9</p> </li> </ol>"},{"location":"Data%20Acquisition/Dev%20Guide/","title":"Developer's Guide","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Dev%20Guide/#dev-tools","title":"Dev Tools","text":"<p>The following are necessary and useful for developing the DAQ's firmware.</p> <ul> <li> Code Editors \u2013 Installing CubeIDE and/or VSCode.</li> <li> View Serial Output \u2013 Read logs transmitted from the device.</li> </ul> <p>The following pages are for those curious about using VSCode as a development environment, instead of STM32 Cube IDE. It is very much possible and doable. The only caveat of using VSCode is that the user must re-import the CubeIDE project every time a CubeMX setting is changed. Importing is done through the official STM32 extension.</p> <ul> <li> Build, Flash, and Debug \u2013 Run the firmware on the microcontroller development board.</li> <li> View Threads, Queues, and Memory \u2013 Extra debugging tools to examine data within concurrency.</li> </ul> <p>Note</p> <p>An alternative is to compile Makefiles. This can be generated by the CubeMX stand-alone app. That is, Makefile generation is not offered through the CubeMX that is made available on CubeIDE. So, no project settings are saved \u2014 which is a huge drawback for our use-case while project requirements may be ill-defined and continue to change.</p>"},{"location":"Data%20Acquisition/Dev%20Guide/#automation-and-devops-tools","title":"Automation and DevOps Tools","text":"<p>The following tools enable us to leverage DevOps to introduce automation for efficiently sustaining a long-term project.</p> <ul> <li> Unit Testing \u2013 Test Driven Development (TDD) and Countinuous Integration (CI).</li> <li> Source Code Docs \u2013 Writing API docs and Continuous Delivery (CD).</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/#standardized-practices","title":"Standardized Practices","text":"<p>Records of team-agreed standards to maintain consistency within our development. These are by no means a mandate, and may be modified overtime.</p> <ul> <li> Contributing and Version Control \u2013 Maintaining traceability between branches and issues.</li> <li> Style Guide \u2013 Consistent code formatting patterns.</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/#project-configurations","title":"Project Configurations","text":"<ul> <li> Code Generation Configs \u2013 Modifying CubeIDE's organization of the HAL library. </li> <li> Enabling printf( ) \u2013 Overriding C's <code>printf()</code> to output through the UART peripheral.</li> <li> Enabling C++ \u2013 Setting up the environment to compile our codebase.</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/build-flash-debug/","title":"Build, Flash, and Debug","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Dev%20Guide/build-flash-debug/#before-you-start","title":"Before You Start","text":"<ul> <li>To be safe that the <code>.ioc</code> file is not an issue, make sure you can build the program on CubeIDE.</li> <li>Install the following dependencies:<ul> <li>CubeCLT (requires Make &amp; CubeIDE) \u2014 Flashing/erasing the program on the dev board's flash memory.</li> <li>CMake \u2014 Compiling the code.</li> <li>VSCode extensions<ul> <li>Embedded Tools by Microsoft \u2014 Viewing processor registers, RTOS data viewer, etc.</li> <li>C/C++ by Microsoft \u2014 Syntax highlighting.</li> <li>CMake Tools by Microsoft \u2014 a build generator. Note that the STM32 extension also installs Ninja. That is, CMake is leveraging Ninja to perform the compilation and linking, instead of Make.</li> <li>GNU Linker Map Files</li> <li>Arm Assembly</li> </ul> </li> </ul> </li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/build-flash-debug/#opening-the-project","title":"Opening the Project","text":"<ul> <li>Open VSCode after cloning this repo.</li> <li>Under the stm32 extension, import the project's <code>.cproject</code> file.</li> <li>The package manager, <code>vcpackage</code> will immediately start to configure CMake and Ninja for compiling the program.</li> <li>Select a build preset for CMake to use. <code>Release</code> is the most optimized for performance and reduced size of the resulting binaries. However, we cannot debug. So, for development, use the <code>Debug</code> preset. </li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/build-flash-debug/#cleaning-previous-builds","title":"Cleaning Previous Builds","text":"<ul> <li>Deleting old build files (binaries, executables, debugging meta-data, etc.) may be necessary only occasionally.</li> <li>Do this first step if you want to ensure a \"clean build.\"</li> <li>Under the CMake extension, click the ellipsis button to clean the project. This is removing any lingering binaries and executables from previous builds.</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/build-flash-debug/#compilingbuilding","title":"Compiling/Building","text":"<ul> <li>Under the CMake extension, click on the build button.</li> </ul> <ul> <li>You should be able to see the output of building/compiling in the <code>./build/debug/build</code> directory.</li> <li>You will find the following important files: <code>.bin</code>, .<code>hex</code>, and <code>.elf</code> (Executable Linker File). Any one of these files can be used to flash the dev board.</li> </ul> <p>Tip</p> <p>Alternatively, use the following command at the project's root directory:</p> <pre><code>cmake --build ./build/debug/build --target DAQ_System\n</code></pre> <p>Tip</p> <p>Alternatively, use a VSCode task.</p> <ul> <li>Assuming a Windows platform, press <code>ctrl+p</code>.</li> <li>Type <code>task</code>.</li> <li>Select <code>Build</code>.</li> </ul> <p>This task is defined in the <code>.vs/tasks.json</code> file, and uses commands made available through stm32CubeCLT (Command Line Tool).</p>"},{"location":"Data%20Acquisition/Dev%20Guide/build-flash-debug/#flashing-the-board","title":"Flashing the Board","text":"<p>To run the code on the development microcontroller board, we must load the build output (binaries, executables, etc.) into the device's Flash memory. Flashing through CubeIDE is the preferred method.</p> <p>Tip</p> <p>Alternatively, use the following command at the project's root directory:</p> <pre><code>STM32_Programmer_CLI -c port=SWD -w ./build/debug/build/blinkf411.elf 0x08000000\n</code></pre> <p>This command is enabling SWD for programming, and writing to the starting address of the \"code region\" in flash memory (namely, <code>0x08000000</code>).</p> <p>Tip</p> <p>Alternatively, use a VSCode task.</p> <ul> <li>Assuming a Windows platform, press <code>ctrl+p</code>.</li> <li>Type <code>task</code>.</li> <li>Select <code>Flash</code>.</li> </ul> <p>This task is defined in the <code>.vs/tasks.json</code> file, and uses commands made available through stm32CubeCLT (Command Line Tool).</p>"},{"location":"Data%20Acquisition/Dev%20Guide/build-flash-debug/#debugging","title":"Debugging","text":"<ul> <li>Set a breakpoint</li> <li>Launch the debugger</li> </ul> <p>Note</p> <p>Initializing the debugger also flashes the board, but instead uses the Debug profile instead of the Release profile. These two flash settings differ in performance, and sometimes the Relase profile may have different behavior. It's important to test the firmware on the hardware within both profiles.</p> <ul> <li>You can hit \"Resume\" to allow the board to run.</li> </ul> <p></p> <p>This gets you access to:</p> <ul> <li>Local variables</li> <li>Registers</li> <li>Values updated via Watch expressions.</li> <li>Peripheral view \u2014 see the contents of registers and peripherals.</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/build-flash-debug/#flashing-a-custom-board","title":"Flashing a Custom Board","text":"<p>Using SWD is the easiest approach, as it minimizes hardware requirements. Only a minimum of 4 pins need to be accessible, which are to be attached to a debugger/programmer device (such as the ST-Link V2/V3):</p> <ul> <li><code>GND</code></li> <li><code>SWCLK</code></li> <li><code>SWDIO</code></li> <li><code>VDD</code></li> </ul> <p>Flashing may work without the <code>VDD</code> pin being used. However, this may work inconsistently and may fail the flash operation. This is used to read the voltage levels of the target device.</p> <p>Notice that the <code>NRST</code> pin is not being used. This pin is only necessary if the firmware were to re-purpose and configure these pins into something other than SWD.</p>"},{"location":"Data%20Acquisition/Dev%20Guide/code-editors/","title":"Code Editors","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Dev%20Guide/code-editors/#installing-microcontroller-drivers","title":"Installing Microcontroller Drivers","text":"<ul> <li>First, install the drivers of your local host PC. Do not connect the stm32 board just yet.</li> <li>Install and run the ST-Link Driver</li> <li>Follow the instructions in <code>readme.txt</code></li> <li>Next, update the firmware of the stm32 device.</li> <li>Install Nucleo Firmware</li> <li>Run <code>ST-LinkUpgrade.exe</code></li> <li>At this point, connect the STM32 board to your PC with the USB cable</li> <li>Click Connect &gt; confirm Yes to update the board's firmware</li> <li>Your board is now ready to program!</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/code-editors/#installing-the-ide","title":"Installing the IDE","text":"<ul> <li>Get the installer of STM32CubeIDE.</li> <li>For my fellow night owls \ud83e\udd89, here is a Dark Theme Extension extension I enjoy. This works because CubeIDE is essentially Eclipse IDE.</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/code-editors/#download-the-codebase","title":"Download the Codebase","text":"<ul> <li>Run the following <code>git</code> command <pre><code>git clone https://github.com/DallasFormulaRacing/DataAcquisition2.0.git\n</code></pre></li> <li>Import the root directory of the project <code>DAQ_System/</code> into CubeIDE.</li> <li>Import the project's <code>DAQ_System/.cproject</code> file into VSCode using the STM32 extension.</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/code-generator-configs/","title":"Code Generator Configs","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Dev%20Guide/code-generator-configs/#code-generator","title":"Code Generator","text":"<ul> <li>To split the auto-generated code on a per-peripheral basis, open the <code>.ioc</code> file &gt; Project Manager &gt; Code Generator &gt; Enable <code>Generate peripheral initialization as a pair of '.c/.h' files per peripheral</code></li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/contributing-version-control/","title":"Contributing and Version Control","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Dev%20Guide/contributing-version-control/#branching-strategy","title":"Branching Strategy","text":"<ul> <li>To contribute to the codebase, create your branch from <code>develop</code>.</li> <li>Then, raise a Pull Request (PR) \u2014 or, Code Review \u2014 to have your work critiqued and polished. Once the new branch is ready, it will be finally merged to <code>develop</code>.</li> <li>All project developers will be mostly sharing each other's work through the <code>develop</code> branch.</li> <li>The <code>develop</code> branch will occassionally be merged into <code>main</code> as a means of publishing a new release or iteration of the project.</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/contributing-version-control/#general-format","title":"General Format","text":"<p><code>label/[task-number]_task-name</code></p>"},{"location":"Data%20Acquisition/Dev%20Guide/contributing-version-control/#flag-labels","title":"Flag Labels","text":"<ul> <li><code>feature/</code></li> <li><code>refactor/</code></li> <li><code>bug/</code></li> <li><code>docs/</code></li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/contributing-version-control/#creating-a-new-branch","title":"Creating a New Branch","text":"<ul> <li>Pre-pend the associated flag label.</li> <li>Separate the issue number and task name with an underscore <code>_</code></li> <li>For the task field, use Camel Case</li> <li>For the sub-task field, use hyphens <code>-</code></li> </ul> <p>Example</p> <p>Consider a new firmware component, the ECU. Looking at the CAN Interface issue on the project board, we can deduct the following:</p> <ul> <li>Issue ID Number: 18 \u2014 found next to the title, denoted by <code>#</code>.</li> <li>Labels: This is a feature, and contributes to the ECU.</li> </ul> <p>Branching from <code>develop</code>, our new branch can be <code>feature/18_minimum-can-interface</code></p> <pre><code>---\ntitle: Git Workflow\n---\n%%{init: {'theme': 'base'} }%%\ngitGraph LR:\n    commit\n    commit\n\n    branch develop\n    checkout develop\n    commit\n\n    branch doc/126_uml-diagrams\n    checkout doc/126_uml-diagrams\n    commit\n    commit\n\n    checkout develop\n    commit\n\n    branch feature/18_minimum-can-interface\n    checkout feature/18_minimum-can-interface\n    commit\n\n    checkout develop\n    merge feature/18_minimum-can-interface\n\n    checkout main\n    merge develop\n    commit\n\n    checkout doc/126_uml-diagrams\n    commit</code></pre>"},{"location":"Data%20Acquisition/Dev%20Guide/contributing-version-control/#things-to-keep-in-mind","title":"Things to Keep in Mind","text":"<ul> <li>Using slashes <code>/</code> in branch names makes a nice drop-down structure of your branches on your GUI Git application (GitHub Desktop, SourceTree, GitKraken, etc). \ud83c\udf8a</li> <li>Auto-generated numbers from creating an issue will ensure we always have unique branch names. Our efforts will be associated with the correct issue accordingly in the long-term for traceability.</li> <li>Issues are found in the GitHub project board.</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/enabling-cpp/","title":"Enabling C++","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Dev%20Guide/enabling-cpp/#separating-c-c","title":"Separating C &amp; C++","text":"<ul> <li>Reference article: Where to add new h and cpp file in stm32cubeide project</li> <li>Creating a separate <code>Program/</code> folder with <code>app.hpp</code> and <code>app.cpp</code> that contains a new super loop function to escape from the auto-generated <code>main.c</code> super loop.</li> <li>Right-click Project &gt; Properties &gt; C/C++ Build &gt; Tool Setting (tab) &gt; MCU GCC Compiler or MCU G++ Compiler &gt; Include paths</li> <li>For C++ files, change the Include Paths config for the G++ compiler instead of the GCC compiler</li> </ul> <p>Then, you may get an \"undefined reference\" error for the calling code. In this case, <code>cppMain()</code> had an undefined reference, despite the <code>#include \"\"</code> lines and changing the Include Paths settings of the compiler. - Reference article: Undefined reference to function stm32cubeide - Right-click Project &gt; Properties &gt; C/C++ General &gt; Paths and Symbols &gt; \"Source Location\" tab &gt; Add Folder</p> <p></p> <p>Finally, you may need to add <code>extern</code> guards. In this case because C++ code was calling for <code>retarget.h</code>, a C file, the following changes was made: <pre><code>// All credit to Carmine Noviello for this code\n// https://github.com/cnoviello/mastering-stm32/blob/master/nucleo-f030R8/system/include/retarget/retarget.h\n\n#ifndef _RETARGET_H__\n#define _RETARGET_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// The rest of the code\n...\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif //#ifndef _RETARGET_H__\n</code></pre></p>"},{"location":"Data%20Acquisition/Dev%20Guide/enabling-cpp/#excluding-from-build","title":"Excluding from Build","text":"<p>Sometimes it may be useful to exclude specific files or sub-directories from being compiled. This can be done by double-clicking the parent-folder of interest in the \"Source Location\" tab of the \"Paths and Symbols\" window. Then, add any directories you do not want to be compiled when building the CubeIDE project.</p> <p>For example, after moving our firmware libraries to a separate repository as a git submodule, we do not want the <code>Tests/</code> and <code>Docs/</code> directory to be compiled and flashed to the microcontroller as they are intended to run in different environments. So, for firmware development, exclude them from build as shown below.</p> <p></p>"},{"location":"Data%20Acquisition/Dev%20Guide/enabling-printf/","title":"Enabling <code>printf()</code>","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Dev%20Guide/enabling-printf/#printf-retargeting","title":"<code>printf()</code> Retargeting","text":"<ul> <li>Via UART/USART: Shawn Hymdel's article, How to Use printf on stm32.</li> <li>Remove <code>syscall.c</code> from build.</li> <li>Uses <code>UART_HAL_Transmit()</code> when overriding the C library functions.</li> <li>Make sure to add the <code>RetargetInit()</code> function.</li> </ul> <p>Note that <code>printf()</code> is not ideal for use in an RTOS environment. A lot of C features are not thread-safe.</p>"},{"location":"Data%20Acquisition/Dev%20Guide/enabling-printf/#enabling-floating-point-values-for-printf","title":"Enabling Floating Point Values for <code>printf()</code>","text":"<p>Right-click project &gt; Properties &gt; C/C++ Build &gt; Settings &gt; MCU Settings &gt; Enable <code>Use float with printf from newlib-nano (-u _printf_float)</code></p> <p></p> <p>This caused the following errors/warnings:</p> <p></p> <p></p> <p>To fix this, the following functions were added to the <code>retarget</code> files with empty implementations: - <code>_getpid()</code> - <code>_kill()</code> - <code>_exit()</code></p> <p>Warning</p> <p>Although this enables floating point values for printing, the floats are printed on the serial console only if the firmware is compiled/flashed with CubeIDE. It seems that enabling this compiler flag does not carry over to the VSCode environment using ST's extension.</p> <p>Warning</p> <p>This setting is important for data logging to function with floating-point values. This must be considered when using other \"printing operations\" when handling strings, such as <code>snprintf()</code>. Omitting this step may cause the result output to be blank in places where the float variable is expected to be.</p>"},{"location":"Data%20Acquisition/Dev%20Guide/source-code-docs/","title":"Source Code Docs","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Dev%20Guide/source-code-docs/#how-it-works","title":"How it Works","text":"<p>Three tools are used for our API documentation:</p> <ul> <li>Doxygen \u2014 A standardized tool for generating docs by scanning C/C++ source code.</li> <li>Sphinx \u2014 A more modernized documentation tool.</li> <li>Breathe \u2014 For connecting Doxygen and Sphinx together.</li> </ul> <p>Doxygen does a great job, and is reliable \u2014 but looks somewhat outdated. For a fresh look, Sphinx is used by building the final HTML pages. Doxygen has been configured to generate XML files in addition to HTML files. Breathe will take these XML files as an input and somehow allows Sphinx to generate HTML pages. This offers us the following benefits:</p> <ul> <li>Using a <code>sphinx-build</code> command instead of creating a build system with CMake or Makefiles.</li> <li>Flexible personalization of themes and colors.</li> <li>Enabling auto-building and serving with an HTTP server using the sphinx-autobuild tool.</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/source-code-docs/#generating-viewing-documentation","title":"Generating &amp; Viewing Documentation","text":"<p>Move into the DAQ-Firmware-Libraries sub-module repo.</p> <pre><code>cd ./Project/DAQ_System/Program/DFR_Libraries\n</code></pre> <p>Build the Docker image: <pre><code>docker build -t ubuntu-docs-image ./Docs\n</code></pre></p>"},{"location":"Data%20Acquisition/Dev%20Guide/source-code-docs/#auto-build-with-http-server","title":"Auto-build with HTTP Server","text":"<p>Create and start the container with auto-build: <pre><code>docker run --rm -it --init -p 8000:8000 --name daq-docs-container -v .:/Project ubuntu-docs-image\n</code></pre></p> <ul> <li>Changes to doc files (<code>.rst</code> or <code>.md</code> files) will be automatically re-built and displayed.</li> <li>When done, cancel the process with <code>Ctrl+C</code>. This will delete the container and stop serving the doc pages on port 8000.</li> <li>Note that this command must be re-run if making changes to the doc comments in the source code.</li> </ul> <p>If successful, you will see some output that is similar to the following:</p> <p></p> <ul> <li>You will now have newly generated docs as HTML files in <code>Project/Docs/_build/html</code>.</li> <li>The main landing page is <code>index.html</code>.</li> <li>To view the doc pages, go to localhost:8000 in your browser.</li> <li>Alternatively, the Live Preview VSCode extension may be more performant. You can then view the docs by right-clicking <code>index.html</code> and selecting \"Show Preview.\" The resulting VSCode window can be popped out into your browser.</li> <li>Alternatively, you can manually open the HTML files on Chrome through the file explorer.</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/source-code-docs/#manual-build","title":"Manual Build","text":"<p>As opposed to using Docker to build and serve the docs to you, you can build the docs manually inside the container.</p> <p>Create and start container: <pre><code>docker run --entrypoint=/bin/bash -itd -p 8000:8000 --name daq-docs-container -v .:/Project ubuntu-docs-image\n</code></pre></p> <ul> <li>Here, the container is not automatically deleted.</li> <li>The container is overwritten to do nothing (using <code>--entrypoint-/bin/bash</code>) instead of the starting command (specified with <code>CMD []</code> at the end of the Dockerfile</li> </ul> <p>Enter the container: <pre><code>docker attach daq-docs-container\n</code></pre></p> <p>Move into the Docs directory: <pre><code>cd Docs\n</code></pre></p> <p>Re-build docs: <pre><code>sphinx-build . ./_build\n</code></pre></p> <p>When you are done, type <code>Ctrl+D</code> to exit the container.</p> <p>Note that you can run the following command for auto-building:</p> <p><pre><code>sphinx-autobuild --re-ignore xml/ --port 8000 --host 0.0.0.0 Docs Docs/_build/html\n</code></pre> - This is the command automatically used when the docker container starts if you were to follow the Auto-build approach. - Must be used in the <code>Project/</code> directory, unless you change the parameters.</p>"},{"location":"Data%20Acquisition/Dev%20Guide/source-code-docs/#manual-makefile-build","title":"Manual Makefile Build","text":"<p>Danger</p> <p>The <code>sphinx-build</code> command approach is highly suggested as the following approach will soon be deprecated.</p> <p>Sphinx has reported that the Makefile may be going deprecated. So, the <code>sphinx-build</code> command tool is preferred.</p> <p>Clean old previous builds: <pre><code>make clean\n</code></pre></p> <p>Generate docs: <pre><code>make html\n</code></pre></p>"},{"location":"Data%20Acquisition/Dev%20Guide/style-guide/","title":"Style Guide","text":"<p>This page was last updated: September 3, 2024</p> <ul> <li>Generally, we will follow the Google C++ Style Guide</li> <li>However, overtime, we will make our adopt our own preferences and document them here</li> <li>This will help maintain our code clean and consistent as we collaborate</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/unit-testing/","title":"Unit Testing","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Dev%20Guide/unit-testing/#building-the-linux-environment-using-docker","title":"Building the Linux Environment using Docker","text":"<p>First, install Docker Desktop. Creating an account is not necessary for our use case.</p> <p>Move into the DAQ-Firmware-Libraries sub-module repo.</p> <pre><code>cd ./Project/DAQ_System/Program/DFR_Libraries\n</code></pre> <p>Build the docker image using the Dockerfile: <pre><code>docker build -t ubuntu-tests-image ./Tests\n</code></pre></p> <p></p> <p>Using the image, create a container, start the container, and mount the volume to the project:</p> <ul> <li>This command must be used at the shared parent directory of both <code>Tests/</code> and the firmware.</li> <li>Execute this specific command in command prompt, not git bash. Git bash somehow alters the path and causes an error.</li> </ul> <pre><code>docker run -itd --name daq-test-container -v .:/Project ubuntu-tests-image\n</code></pre> <p>Attach the image's terminal input/output to yours: <pre><code>docker attach daq-test-container\n</code></pre></p> <p>The first two commands only have to be done once. Your host PC will store the docker image and docker container. To use the docker Linux environment in a later session, simply use the <code>attach</code> command and repeat the steps below.</p>"},{"location":"Data%20Acquisition/Dev%20Guide/unit-testing/#compiling-and-running-unit-tests","title":"Compiling and Running Unit Tests","text":"<p>Once you are running in the container, move into the unit testing directory: <pre><code>cd Tests\n</code></pre></p> <p>Use CMake to generate a build system:</p> <ul> <li>Specify Ninja as the build system with the <code>-G</code> flag. Omitting this flag will default to using Make for the compilation process, which is slower than Ninja.</li> <li>Specify the path to the source code to be built with the <code>-S</code> flag.</li> <li>Specify the path for storing the build output (cache, executable, etc.)<ul> <li>Creates the <code>DAQ_System/Tests/build</code> folder if it does not exist.</li> <li>This is where configurations for the Ninja build system are stored.</li> <li>This command needs to be used only when you need to create this folder.</li> </ul> </li> </ul> <pre><code>cmake -G \"Ninja\" -S . -B ./build\n</code></pre> <p>For compiling, move into the new folder (your build system environment). From here on out, we only need to use Ninja commands. <pre><code>cd build\n</code></pre></p> <p>Compile the GoogleTest framework and our unit tests:</p> <ul> <li>Ninja detects when the shell terminal is used and automatically overwrites the same terminal line. To see a multi-line output of the order in which the files are being built, concatenate and print the output using <code>cat</code>. That is, use the <code>ninja | cat -</code> command instead.</li> <li>If seeing every detail of the output is necessary, use <code>ninja -v</code> to enable verbose (ugly, but informative) output.</li> <li>Otherwise, the below command will show the build output in only one line.</li> </ul> <pre><code>ninja\n</code></pre> <p></p> <p>Run the resulting executable: <pre><code>./daq-unit-tests\n</code></pre></p> <p></p>"},{"location":"Data%20Acquisition/Dev%20Guide/unit-testing/#cleaning-build-files","title":"Cleaning Build Files","text":"<p>Sometimes, a \"clean build is necessary.\" That is, to clean (remove all \"dirty\" or old build files) and re-build from scratch. You only need two commands: <pre><code>ninja clean\nninja\n</code></pre></p> <p>If there is any doubt of whether absolutely everything is removed (such as cached files), you can manually delete the <code>./build</code> folder and re-run the <code>cmake</code> command to recreate it with new build system configurations.</p> <p>When you are done, type <code>exit</code> to leave the container.</p>"},{"location":"Data%20Acquisition/Dev%20Guide/unit-testing/#good-to-know","title":"Good to Know","text":"<p>It is worth noting that building with <code>make</code> instead of <code>ninja</code> more explicitly shows how a file is compiled to a target link library. That is, the output shows the <code>hello_tests.cc</code> was built and linked into the <code>daq-unit-tests</code> target link library (executable). This more accurately reflects the <code>CMakeLists.txt</code> file and may be helpful to keep in mind when adding more files to be linked.</p> <p></p>"},{"location":"Data%20Acquisition/Dev%20Guide/unit-testing/#official-docs","title":"Official Docs","text":"<ul> <li>Docker</li> <li>Google Test</li> <li>CMake</li> <li>Ninja</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/view-serial-output/","title":"Viewing Serial Output","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Dev%20Guide/view-serial-output/#serial-viewer-on-vscode","title":"Serial Viewer on VSCode.","text":"<ul> <li>Download the Serial Viewer extension.</li> <li>Open the Serial Monitor tab in the terminal.</li> <li>Configure the settings as necessary.</li> </ul> <p>For example: Suppose a USART peripheral is outputting serial data through a virtual COM port using the following configurations:</p> <p> </p> USART initialization code auto-generated by CubeMX <p>Note</p> <p>For the 8-bit word length configured on USART, we set 7 data bits on the Serial Viewer. This is because the 8th bit is the stop bit.</p> <p>So, we match these settings on the Serial Viewer:</p> <p></p> <p>Tip</p> <p>This VSCode extension allows you to log serial output as a text file and is incredibly useful for viewing serial output with a high payload and frequency.</p>"},{"location":"Data%20Acquisition/Dev%20Guide/view-serial-output/#tera-term","title":"Tera Term","text":"<p>This is recommended for end users, not maintainers and developers. Tera Term allows for configuring the receiving serial port of a user's computer to match the transmitter's settings and can be downloaded here.</p> <p>Example</p> <p>Connect the Arduino Uno R3 to your computer via USB. Open Tera Term. Select Serial and the corresponding device port. Select Ok.</p> <p> </p> Initial connection settings <p> </p> Output"},{"location":"Data%20Acquisition/Dev%20Guide/view-threads-queues-memory/","title":"Viewing RTOS Threads, Queues, and Memory","text":"<p>This page was last updated: September 3, 2024</p> <ul> <li>Start a debugging session.</li> <li>Open the Embedded Tools tab in the terminal.</li> </ul> <p></p>"},{"location":"Data%20Acquisition/Dev%20Guide/view-threads-queues-memory/#threads","title":"Threads","text":"<ul> <li>The RTOS Viewer provides threads by default.</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/view-threads-queues-memory/#queues","title":"Queues","text":"<ul> <li>Click the ellipses at the top-right corner of the terminal and select Queues.</li> </ul>"},{"location":"Data%20Acquisition/Dev%20Guide/view-threads-queues-memory/#viewing-memory","title":"Viewing Memory","text":"<ul> <li>Clicking on the hex values of an associated thread/queue will allow you to inspect the memory contents.</li> <li>You may be prompted to install the Hex Editor extension.</li> </ul> <p>Example</p> <ul> <li>Clicking on the address of the Stack Ptr, <code>0x2000 0a14</code>, belonging to the <code>IDLE</code> thread yields the following contents.</li> <li>The accompanying Decoded Text corresponds to the Memory Map.</li> <li>You can configure whether to show the Decoded Text and how many bytes to display per row using the settings button on the top-left corner of the memory map.</li> </ul> <p></p> <p>Example</p> <p>Let's look at the contents of <code>0x0000 0038</code>. You can hover your mouse over it or click it.</p> <ul> <li>The contents of it is displayed as hex <code>0x51</code>.</li> <li>The contents reveal that, as a <code>uint8</code> integer, this value is decimal <code>81</code>.</li> <li>Hex <code>0x51</code> is decoded to ASCII <code>Q</code> in UTF-8.</li> <li>Note that you can enable/disable Little Endian</li> </ul> <p></p> <p>But how is the data decoded for the other data types, such as <code>uint16</code>? Inspect the binary values of two addresses at a type. One pair of hex digits equates to two bytes (i.e., only 8 bits). Inspect the contents of <code>0x0000 0039</code>. Concatenating the binary values stored here with the binary values from <code>0x0000 0038</code> while Little Endian is disabled: <code>0x01010001 00010011</code> yields a <code>uint16</code> integer value of decimal 20755, which is shown when inspecting <code>0x0000 0038</code> (also known as, <code>0x51</code>).</p> <p></p> <p>Enabling Little Endian should require the concatenation to be swapped: <code>0x00010011 01010001</code> yields a <code>uint16</code> integer of 4945. We can verify this by inspecting <code>0x0000 0038</code>.</p> <p></p> <p>Example</p> <ul> <li>In the Task1 thread, a byte array <code>data</code> is initialized with <code>Hello TASK1\\n</code>.</li> <li>To find this in memory, click on the Stack Start address (<code>0x2000 0ed0</code>) of the Task1 Thread.</li> <li>You will find the decoded ASCII characters in the Decoded Text area.</li> </ul> <p></p>"},{"location":"Data%20Acquisition/Firmware%20Design/","title":"Firmware Design","text":"<ul> <li> Architecture Overview \u2013 Organization and separation of responsibilities among components.</li> <li> File Structure \u2013 A walkthrough of the project repository.</li> <li> Timing and Concurrency \u2013 Strategies to support real-time behavior.</li> </ul>"},{"location":"Data%20Acquisition/Firmware%20Design/architecture-overview/","title":"Architecture Overview","text":"<p>This codebase utilizes the Layered Architecture. In practice, this is reflected in the firmware by separating each layer with folder directories and C++ namespaces while encouraging loosed coupling between components.</p>"},{"location":"Data%20Acquisition/Firmware%20Design/architecture-overview/#application-layer","title":"Application Layer","text":"<ul> <li>High-level code.</li> <li>Will mostly consist of logic rather than nitty-gritty details.</li> <li>Will not be constrained to a particular product.</li> </ul>"},{"location":"Data%20Acquisition/Firmware%20Design/architecture-overview/#sensor-layer","title":"Sensor Layer","text":"<ul> <li>Low-level code.</li> <li>Consists of drivers. That is, libraries to support sensors and external devices.</li> <li>Product-specific code.</li> </ul>"},{"location":"Data%20Acquisition/Firmware%20Design/architecture-overview/#platform-layer","title":"Platform Layer","text":"<ul> <li>Low-level code.</li> <li>Access to microcontroller peripherals.</li> <li>Platform-specific code. Such as, making use of I2C on an STM32 with the HAL library vs. on a TI microcontroller.</li> </ul>"},{"location":"Data%20Acquisition/Firmware%20Design/architecture-overview/#diagrams","title":"Diagrams","text":"<pre><code>---\ntitle: Simplified Architecture Diagram\n---\nclassDiagram\ndirection TB\n\nnamespace Application Layer {\n    class DAQ {\n        bool file_is_open\n        char file_name_[16]\n        char write_buffer\n        uint8_t status\n        void Init()\n        void Read()\n        void Write()\n    }\n\n    class IDataLogger {\n        &lt;&lt;interface&gt;&gt;\n        char write_buffer_;\n\n        uint8_t Mount(BlockDevice*)*\n        uint8_t Unmount()*\n        uint8_t FileOpen(char*)*\n        uint8_t FileClose()*\n        uint8_t FileWrite(cost char*)*\n    }\n}\n\nnamespace SensorLayer {\n    class IEcu {\n        &lt;&lt;interface&gt;&gt;\n    }\n\n    class IAccelerometer {\n        &lt;&lt;interface&gt;&gt;\n        GetAcceleration()*\n        ComputeAcceleration()*\n    }\n\n    class GenericSensor {\n        &lt;&lt;interface&gt;&gt;\n    }\n}\n\nnamespace Platform Layer {\n    class ISpi {\n        &lt;&lt;interface&gt;&gt;\n    }\n\n    class IUsb {\n        &lt;&lt;interface&gt;&gt;\n    }\n\n    class ICan {\n        &lt;&lt;interface&gt;&gt;\n    }\n\n    class II2c {\n        &lt;&lt;interface&gt;&gt;\n    }\n\n    class GenericPeripheral {\n        &lt;&lt;interface&gt;&gt;\n    }\n}\n\nDAQ --&gt; IDataLogger\nDAQ --&gt; IAccelerometer\nDAQ --&gt; GenericSensor\n\nIEcu --&gt; ICan\nIDataLogger --&gt; ISpi\nIDataLogger --&gt; IUsb\nIAccelerometer --&gt; II2c\nGenericSensor --&gt; GenericPeripheral\n\nend</code></pre> <p>Note</p> <p>This diagram is simplified by removing the concrete/implementation classes. In reality, the concrete classes (i.e., the implementation of the abstract interfaces) utilize the abstract interfaces of the Platform layer. For instance, a specific implementation of the Accelerometer (not <code>IAccelerometer</code>) may utilize the <code>II2C</code> interface.</p> <p>The complete, more accurate illustration of the architecture is shown below.</p> <p>Coming soon...</p>"},{"location":"Data%20Acquisition/Firmware%20Design/file-structure/","title":"File Structure","text":""},{"location":"Data%20Acquisition/Firmware%20Design/file-structure/#overall-repo","title":"Overall Repo","text":"<ul> <li>The <code>DAQ_System</code> folder will be the workspace intended to be the final deliverable. This is the actual codebase we are working towards.</li> </ul> <pre><code>flowchart LR\n    %% Colors %%\n    classDef blue fill:#66deff,stroke:#000,color:#000\n    classDef green fill:#6ad98b,stroke:#000,color:#000\n    classDef yellow fill:#f2d994,stroke:#000,color:#000\n\n    root[\"DataAcquisition2.0\"]--&gt;Project(\"Project\")\n    Project--&gt;DAQ_System(\"DAQ_System\")\n    Project--&gt;Docs;\n    Project--&gt;Tests\n\n\n    subgraph DAQ_System Workspace\n        direction LR\n        DAQ_System:::blue\n        DAQ_System--&gt;Source(\"Program/Src\")\n        Source--&gt;Application(\"Application\")\n        Source--&gt;Sensor(\"Sensor\")\n        Source--&gt;Platform(\"Platform\")\n        Source--&gt;DAQ_Main(\"app.cpp\"):::green\n    end\n</code></pre>"},{"location":"Data%20Acquisition/Firmware%20Design/file-structure/#legend","title":"Legend","text":"<ul> <li>Blue \u2014 Root of the workspace</li> <li>Green \u2014 Main file of the workspace</li> </ul>"},{"location":"Data%20Acquisition/Firmware%20Design/file-structure/#daq_system-workspace","title":"DAQ_System Workspace","text":"<pre><code>flowchart LR\n    %% Colors %%\n    classDef blue fill:#66deff,stroke:#000,color:#000\n    classDef green fill:#6ad98b,stroke:#000,color:#000\n    classDef yellow fill:#f2d994,stroke:#000,color:#000\n\n    DAQ_System:::blue\n    DAQ_System--&gt;Source(\"Program/Src\")\n\n    Source--&gt;Application(\"Application\")\n    Source--&gt;Sensor(\"Sensor\")\n    Source--&gt;Platform(\"Platform\")\n    Source--&gt;DAQ_Main(\"app.cpp\"):::green\n\n    Application--&gt;Application_Interfaces(\"Interfaces\")\n    Application--&gt;Application_Logging(\"Logging\"):::yellow\n    Application--&gt;Application_Concurrency(\"Concurrency\"):::yellow\n\n    Sensor--&gt;Sensor_Interfaces(\"Interfaces\")\n    Sensor--&gt;Sensor_Ecu(\"ECU_Model_xxx\")--&gt;Sensor_Acc_Lib(\"ECU Low-Level Library Code\"):::yellow\n\n\n    Platform--&gt;Platform_Interfaces(\"Interfaces\")\n    Platform--&gt;Platform_Can(\"CAN Protocol\")--&gt;Platform_Dependent_Code(\"Platform (Board) Dependent Code\"):::yellow\n    Platform--&gt;Abstracted_Peripherals(\"Abstracted Peripherals\"):::yellow\n</code></pre>"},{"location":"Data%20Acquisition/Firmware%20Design/file-structure/#legend_1","title":"Legend","text":"<ul> <li>Blue \u2014 Root of the workspace</li> <li>Green \u2014 Main file of the workspace</li> <li>Yellow \u2014 Key differences among the layers of code</li> </ul>"},{"location":"Data%20Acquisition/Firmware%20Design/timing-and-concurrency/","title":"Timing and Concurrency","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Firmware%20Design/timing-and-concurrency/#hardware-timer","title":"Hardware Timer","text":"<p>Note</p> <p>Currently, due to the implementation of CubeMx's auto-generated timer callback functions, the hardware timer is not abstracted away and is not kept as a component of the Platform layer. It is minimally implemented in <code>main.c</code>. </p> <p>The DAQ needs an accurate timer to periodically create timetamps that are to be associated with a new data sample. RTOS timers are not simple to implement, but have a less consistent precision. A hardware timer is utilized to meet this requirement.</p> <p>The first step to enabling a hardware timer is to identify the bus it is attached to. A timer's frequency is initially subjected to the frequency of the bus it belongs to. Depending on the implementation of the microcontroller chip, different timers may be attached to different busses. This is platform-dependent.</p> <p>Before continuing, make sure to have a specific timing deadline at which the timer interrupt signal will fire. This will be a parameter for the following calculations.</p> \\[ Bus \\ frequency / Prescaler \\ value = Clock \\ rate \\] \\[ (Time \\ deadline)(Clock \\ rate) = Number \\ of \\ steps \\ or \\ ticks \\] <p>The microcontroller may come with a prescaler, which divides the bus frequency to slow down the rate of the clock. This allows for adjusting the possible range of possible timing deadlines.</p> <p>With a known time deadline, the clock rate can be utilized to determine the total number of clock ticks until it reaches the deadline. Once the number of ticks is reached, the timer will fire the interrupt signal and the pre-determined time deadline. That is, this is the number of ticks required for performing a single periodic interval.</p> <p>Tip</p> <p>Increasing the prescaler and/or number of steps will lengthen the amount of time we can measure with a clock.</p>"},{"location":"Data%20Acquisition/Firmware%20Design/timing-and-concurrency/#stm32-example","title":"STM32 Example","text":"<p>Currently, the DAQ uses the <code>TIM7</code> timer peripheral. This is attached to the APB1 bus. So, \\(Bus \\ frequency = 84 MHz\\).</p> <p></p> <p>For simplicity, we will make the clock tick roughly about 10 KHz. That is, we will divide the bus frequency by 8,000. So, \\(Prescaler \\ value = 8,000 - 1\\).</p> <p>Then, compute: \\((Bus \\ frequency) / (Prescaler \\ value) = (84,000,000) / (8,000 - 1) = 10,501 = Clock \\ rate\\)</p> <p>Say we want the DAQ to to create its timestamp every 2 seconds. Compute: \\((Time \\ deadline)(Clock \\ rate) = (2 \\ seconds)(10,501) = 21,002 = Number \\ of \\ steps \\ or \\ ticks\\)</p> <p>Take note of the prescaler value and the number of ticks. These values will be used in CubeMx. Note that we entered their rounded values.</p> <p></p> <p>Enable the timer signal to trigger an interrupt.</p> <p></p> <p>Enable the following modes for the RCC peripheral.</p> <p></p> <p>Success</p> <p>You can learn further more on DigiKey's Getting Started with STM32 - Timers and Timer Interrupts tutorial.</p>"},{"location":"Data%20Acquisition/Firmware%20Design/timing-and-concurrency/#rtos","title":"RTOS","text":"<p>Note</p> <p>Threads and tasks are synonymous here.</p>"},{"location":"Data%20Acquisition/Firmware%20Design/timing-and-concurrency/#multi-threading","title":"Multi-threading","text":"<ul> <li>Each firmware component is dedicated its own thread. Therefore, each firmware component has its own dedicated super loop.</li> <li>Note that if the microcontroller only has 1 core, then only one thread will run at a time despite having numerous threads.</li> <li>List of threads:<ul> <li>One each for every sensor</li> <li>Data logging</li> <li>Time stamping</li> </ul> </li> </ul>"},{"location":"Data%20Acquisition/Firmware%20Design/timing-and-concurrency/#scheduling","title":"Scheduling","text":"<ul> <li>Task priorities enabled.</li> <li>Preemptive scheduling enabled: At every tick, the scheduler will check whether a higher-priority task is Ready to run. This will preempt over the currently running task and the processor will run the higher-priority task, putting a pause to the lower-priority task.</li> <li>Most threads run indefinitely in a forever-loop. However, the timestamping thread is an exception. By using CMSIS-RTOS V2's Thread Flags feature, this particular thread will run when the Hardware Timer signals it to.</li> </ul> <p>Warning</p> <p>A logically higher-priority task is usually represented with a numerical value closer to 0. That is, the lower the priority number, the higher the priority.</p> <p>Tip</p> <p>It is recommended for tasks that are responsible to provide fast interaction to the user to run fairly often. Components such as the <code>DataLogger</code> may benefit from being suspended less often in comparison to other threads.</p> <p>Tip</p> <p>For determining which CMSIS-RTOS V2 features are safe to perform in an Interrupt Sub-Routine (ISR), you can check their List of ISR-safe features.</p>"},{"location":"Data%20Acquisition/Firmware%20Design/timing-and-concurrency/#data-sharing","title":"Data Sharing","text":"<p>Two components are declared as global objects and shared among multiple threads: DataPayload and CircularQueue.</p> <p>A single instance of a <code>DataPayload</code> object is updated by all sensor-reading threads. The time stamping thread will periodically create a copy of this object as a means of sampling, and associate a newly created timestamp with it. This new copy of <code>DataPayload</code> containing a timestamp is inserted into the <code>CircularQueue</code>.</p> <p>Only two threads need to share the <code>CircularQueue</code>: the timestamping thread and the data logging thread. The <code>DataLogger</code> will check for a new instance of <code>DataPayload</code> to log. </p> <p>These two shared objects must be guarded by a mutex. Generally, with any shared resource, a thread should request for its access before making use of it. A mutex forces the threads to use a shared resource in sequence (one at a time) instead of allowing them to interrupt each other and corrupt information.</p> <p>The timestamping thread has higher priority than the sensor threads due to its strict deadline. Using a mutex before accessing the shared <code>DataPayload</code> instance will prevent the timestamping thread from interrupting a sensor thread from when halfway to updating with a new sensor reading.</p> <p>Using a mutex before accessing the shared <code>CircularQueue</code> will ensure the queue's status of whether it is full or empty to be more accurate.</p>"},{"location":"Data%20Acquisition/Firmware%20Design/timing-and-concurrency/#timestamp-creation","title":"Timestamp Creation","text":"<p>The currenty strategy to creating a relative timestamp (that is, a measurement of time in respect to the start of the data logging session), is simple:</p> <ul> <li>With a known timing deadline, you will know when the timer interrupt will occur.</li> <li>Create a counter variable.</li> <li>Within the interrupt callback function, increment the counter variable.</li> <li>The Timestamp thread will compute the timestamp by multiplying your known time deadline with the counter variable.</li> </ul> \\[ (Time \\ deadline)(Number \\ of \\ timer \\ interrupt \\ signals) = Timestamp \\] <p>In the earlier example, we have decided a deadline of 2 seconds. If 7 seconds have passed, then we can expect the counter variable to have counted 3 timer interrupts, each 2 second apart.</p> <p>This is why the Timestamp thread is the most time-critical.</p>"},{"location":"Data%20Acquisition/Firmware%20Design/timing-and-concurrency/#process-summary","title":"Process Summary","text":"<p>Consider the following scenario.</p> <p></p> <ul> <li><code>DataLogger</code> is responsible for user-interaction and must prevent the <code>CircularQueue</code> from overflowing. Naturally, we will have this task run more often with higher priority.</li> <li><code>DataLogger</code> successfully locks <code>CircularQueue</code> to check for data to log.</li> <li>Since no other firmware component has locked the <code>CircularQueue</code>, <code>DataLogger</code> successfully claimed it for its use.</li> <li>Since <code>DataLogger</code> has higher priority than the sensor threads, it is not preempted and therefore completes its task without interruption before suspending itself.</li> </ul> <p>This first transaction is the best case scenario for performance. Without other threads trying to lock the same shared resource, there is less context switching \u2014 this is known to be the largest cause of delay in multi-threading.</p> <ul> <li><code>LinPots</code> lock an instance of <code>DataPayload</code>.</li> <li>However, suppose that the <code>ECU</code> has higher priority, <code>LinPots</code> is preempted and put to a pause.</li> <li><code>ECU</code> tries to claim <code>DataPayload</code>, but it is already claimed by <code>LinPots</code>. So, <code>ECU</code> is suspended.</li> <li>The processor returns to <code>LinPots</code> to finish the job and release the mutex.</li> <li>With <code>DataPayload</code> available, the processor continues with <code>ECU</code>'s attempt to lock it.</li> <li><code>ECU</code> finishes its task and releases <code>DataPayload</code>.</li> </ul> <p>The mutex between these two threads is technically not necessary, as they are both updating different fields of the <code>DataPayload</code> struct. Rather, the mutex is there to handle sharing with the <code>Timestamp</code> thread. This is demonstrated next.</p> <ul> <li>The <code>IMU</code> thread claims <code>DataPayload</code>.</li> <li><code>IMU</code> is preempted by <code>DataLogger</code> due to having lower priority.</li> <li><code>DataLogger</code> claims the <code>CircularQueue</code>.</li> <li>The hardware timer triggers <code>Timestamp</code> to run. This has higher priority and preempts over <code>DataLogger</code>.</li> <li><code>Timestamp</code> fails to lock <code>DataPayload</code>, as it is already claimed by <code>IMU</code>. This thread is suspended.</li> <li>The processor returns to <code>DataLogger</code> and finishes the task. <code>CircularQueue</code> is released.</li> <li>The processor returns to <code>IMU</code> to finish the task. <code>DataPayload</code> is released.</li> <li>With <code>DataPayload</code> finally available, the <code>Timestamp</code> thread continues its task and locks the <code>CircularQueue</code>.</li> <li><code>Timestamp</code> finishes its task by inserting a copy of <code>DataPayload</code> into <code>CircularQueue</code>.</li> </ul> <p>Without the <code>DataPayload</code> mutex, the <code>Timestamp</code> thread could be sampling an incomplete instance of data if it were to interrupt a sensor thread mid-updating.</p> <p>Without the <code>CircularQueue</code> mutex, the <code>DataLogger</code> may be less efficient with checking if the queue is empty. And <code>Timestamp</code> may be less efficient with checking if the queue is full.</p>"},{"location":"Data%20Acquisition/Sensor/Accelerometer/","title":"Accelerometer","text":""},{"location":"Data%20Acquisition/Sensor/Accelerometer/#description","title":"Description","text":"<p>Reading the accleration in \\(G\\)s or \\(m/s^2\\) of the X, Y, and Z axis.</p>"},{"location":"Data%20Acquisition/Sensor/Accelerometer/#supported-sensors","title":"Supported Sensors","text":"<pre><code>classDiagram\n\nnamespace SensorLayer {\n    class IAccelerometer {\n        &lt;&lt;interface&gt;&gt; \n\n    }\n\n    class LSM303DLHC { }\n}\n\nnamespace Platform Layer {\n    class II2C {\n        &lt;&lt;interface&gt;&gt;\n    }\n}\n\nIAccelerometer &lt;.. LSM303DLHC\nLSM303DLHC --&gt; II2C\n\nlink LSM303DLHC \"lsm303dlhc/\"\n\nend</code></pre>"},{"location":"Data%20Acquisition/Sensor/Accelerometer/lsm303dlhc/","title":"LSM303DLHC","text":""},{"location":"Data%20Acquisition/Sensor/Accelerometer/lsm303dlhc/#details","title":"Details","text":"<p>Sensor Datasheet </p> <p></p> <ul> <li>Sensor: LSM303DLHC Accelerometer.<ul> <li>Sensor is made by ST.</li> <li>Breakout board is provided by Adafruit.</li> </ul> </li> <li>Frequency:</li> <li>Communication: I2C.</li> </ul>"},{"location":"Data%20Acquisition/Sensor/Accelerometer/lsm303dlhc/#pinout","title":"Pinout","text":""},{"location":"Data%20Acquisition/Sensor/Accelerometer/lsm303dlhc/#firmware","title":"Firmware","text":"<p>Library API Docs </p>"},{"location":"Data%20Acquisition/Sensor/Accelerometer/lsm303dlhc/#calibration","title":"Calibration","text":"<ul> <li>Digitally Representing \u00b1 2G</li> <li>Averaged the magnitude of the sensor output for a period where it was not touched to find a correcting factor that would theoretically translate to 1.0G. After the program ran for several minutes, the average value for 1.0G was 1024. </li> <li>Note that at this point, firmware has already been developed for converting raw data to m/s^2 and Gs</li> <li>This solution was by comparing the data read by the accelerometer to the data read from an iPhone accelerometer</li> </ul>"},{"location":"Data%20Acquisition/Sensor/Accelerometer/lsm303dlhc/#addressing-drift","title":"Addressing Drift","text":"<ul> <li>Testing the sensor another day for drift, we found that the average output that day was less than when we first started testing than after running the accelerometer for a few minutes. </li> <li>The correction value could change due to unknown external and internal conditions, it was decided that the sensor would need to be recalibrated during start-up and after running for certain periods of time. </li> <li>The calibration function was created by taking the idea that an average of data taken for 100 loops while the sensor was restarted could be used as a correction value. If the minimum and maximum values of those samples had a deviation above 0.1G then the newly produced calibration factor would be thrown out on the assumption that the accelerometer is moving, and the calculated gravitational correction factor is incorrect. The calculated factor will then be thrown out and a predetermined default value will be used.</li> <li>This calibration value is produced by dividing the averaged array by the amount of samples as a conversion factor to \"raw data per single G-force\".</li> </ul>"},{"location":"Data%20Acquisition/Sensor/Accelerometer/lsm303dlhc/#how-to-use","title":"How to Use","text":"<p>Example</p> <p>How to initialize the <code>LSM303DLHC</code> object and read the acceleration of each axis by interacting with the <code>IAccelerometer</code> interface. <pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include \"mbed.h\"\n#include \"../iaccelerometer.hpp\"\n#include \"../accelerometer_lsm303dlhc.hpp\"\n\nint main() {\nfloat* acceleration = nullptr;\nstd::unique_ptr&lt;adapter::IAccelerometer&gt; accelerometer\n    = std::make_unique&lt;adapter::Accelerometer_LSM303DLHC&gt;(I2C_SDA, I2C_SCL);\n\naccelerometer-&gt;init();\n\nwhile (true) {\n    accelerometer-&gt;ComputeAcceleration();\n    acceleration = accelerometer-&gt;GetAcceleration();\n\n    //accelerometer values must be \n    std::cout &lt;&lt; \"ACC:\" &lt;&lt; \n                    \"\\tX: \" &lt;&lt; acceleration[0] &lt;&lt;\n                    \"\\tY: \" &lt;&lt; acceleration[1] &lt;&lt;\n                    \"\\tZ: \" &lt;&lt; acceleration[2] &lt;&lt; std::endl;\n\n    ThisThread::sleep_for(500ms);\n}\n}\n</code></pre></p>"},{"location":"Data%20Acquisition/Sensor/Accelerometer/lsm303dlhc/#registers","title":"Registers","text":""},{"location":"Data%20Acquisition/Sensor/Accelerometer/lsm303dlhc/#slave-address","title":"Slave Address","text":"<p>the LSM303dlhc contains a 7 bit address plus a read/write bit ad the end of the address. meaning that threre are two separate addresses for the lsm303dlhc and which one you use depends on whether you are wrting or reading to the sensor. the 7 bit address is 0011001 then you either add a 1 at the end to indicate a read (00110011) or add a 0 to indicate a write(00110010).</p>"},{"location":"Data%20Acquisition/Sensor/Accelerometer/lsm303dlhc/#ctrl-registers","title":"CTRL Registers","text":"<p>The LSM303DLHC contains 6 Control registers that can be used to modify the characteristics of the accelerometer. However, the most important control register is CTRL_REG1_A. This register has an address of 0x20 and controls Output Data Rate(ODR), Low-power mode, and enabling each axis of the accelerometer. For basic configurations of the lsm303dlhc this is all you need to configure to begin recieving data.</p> <p>Example</p> <p>A I2C register write to set 100 hz pooling rate, disable Low power mode, and enable all three axis. Note: this is a general idea for implemenation acutal code will vary.  <pre><code>RegisterWrite(0x32,CTRL_REG1_A) // RegisterWrite(I2CWriteSlaveAddress, DataToWrite) \nRegisterWrite(0x32,0x57) // 0x57(01010111) is the acutal data written to the regsiter \n</code></pre>   the example demonstrates two different write commands sent to the lsm303dlhc. The first the the address of the regsiter that is going to be written to and the second is the value that will be written to that said address. The other control registers handle different functions like a high pass filter, interupts, Full scale range (FSR), and much more.</p>"},{"location":"Data%20Acquisition/Sensor/Accelerometer/lsm303dlhc/#output-registers","title":"Output Registers","text":"<p>Data is received by registers that are denoted by OUT(OUT_X_L_A, OUT_Y_L_A, etc). each axis is comprised of a L and a H register(i.e OUT_X_L_A and OUT_X_H_A) which denotes the MSB and the LSB of the data ( Note: the endianness of the output can be altered with CTRL_REG4_A ). Which basically means that there will be 6 differnt registers for outputting data.</p> <p>Example</p> <p>The exmaple below is taken direclty from an implementation of the LSM303dlhc utilizing the STM32 HAL.  <pre><code>static constexpr int ByteArraySize = 6;\nstatic constexpr int I2CWriteSize = 1;\nstatic constexpr int I2CReadSize = 6;\nuint8_t command[1] = { OUT_X_L_A | 0x80 };\n\nHAL_I2C_Master_Transmit(&amp;i2c_,ACC_ADDRESS, command,I2CWriteSize, HAL_MAX_DELAY);\n\nuint8_t bytes_received[ByteArraySize];\nHAL_I2C_Master_Receive(&amp;i2c_,ACC_ADDRESS, bytes_received,I2CReadSize, HAL_MAX_DELAY);\n\n// 16-bit values\nraw_acceleration_data_[0] = (bytes_received[1] &lt;&lt;8 | bytes_received[0]);\nraw_acceleration_data_[1] = (bytes_received[3] &lt;&lt;8 | bytes_received[2]);\nraw_acceleration_data_[2] = (bytes_received[5] &lt;&lt;8 | bytes_received[4]);\n</code></pre></p> <p><pre><code>    uint8_t command[1] = { OUT_X_L_A | 0x80 };\n</code></pre> This line of code is a unique property of the lsm303dlhc and other similar accelerometer. Since there are 6 register that need to be constantly read, Most accelerometers provide a way to do sequential reading. This is done by making the MSB bit of the registers address you want to read set to 1. With the MSB bit set to 1, the lsm303dhlc doesn't require any more addresses to be sent to through the I2C line, instead it will auto increment the addresss by 1 and send that data.</p> <p>Each register is 8 bits but each axis needs 16 bits to fully realize the data which means that you will need an array of 6 to hold each data and each axis will need two elements to fully realize that data. The bottom section of the example code demonstrates how the two elements that make up on axis data can be combined into one variable.</p>"},{"location":"Data%20Acquisition/Sensor/ECU/","title":"Engine Control Unit (ECU)","text":"<p>This page was last updated: September 3, 2024</p> <p>Info</p> <p>The ECU is under the <code>Sensor</code> layer as it behaves as an array of sensors with the \"black box\" mindset.</p>"},{"location":"Data%20Acquisition/Sensor/ECU/#description","title":"Description","text":"<p>A CAN node is a device that is participating in the CAN bus network.<sup>1</sup></p> <p> </p> A generic CAN node <p>To build a CAN bus, you need at least two nodes and exactly two 120 Ohm termination resistors. These resistors serve to prevent the signal from reflecting.<sup>2</sup></p> <p> </p> Standardized termination resistors <p>It is highly recommended to twist the CAN Hi and Lo wires for improving signal integrity.<sup>3</sup></p> <p> </p> Twisted Pair Wiring"},{"location":"Data%20Acquisition/Sensor/ECU/#nomenclature","title":"Nomenclature","text":"<p>Keep in mind that CAN 2.0A is equivalent to Classic CAN while CAN 2.0B is equivalent to Extended CAN.</p> <p>Extended CAN is backwards-compatible with Classic CAN, but not vice-versa.</p> <p>CAN FD is a standard exceeding that of Extended CAN.</p>"},{"location":"Data%20Acquisition/Sensor/ECU/#supported-sensors","title":"Supported Sensors","text":"<pre><code>classDiagram\n\nnamespace SensorLayer {\n    class IEcu {\n        &lt;&lt;interface&gt;&gt; \n    }\n\n    class Pe3 { }\n}\n\nnamespace Platform Layer {\n    class ICan {\n        &lt;&lt;interface&gt;&gt;\n    }\n}\n\nIEcu &lt;-- Pe3\nPe3 ..&gt; ICan\n\nlink Pe3 \"pe3/\"\n\nend</code></pre> <ol> <li> <p>What is a CAN Bus System? by Olga Weis.\u00a0\u21a9</p> </li> <li> <p>Introduction to CAN Bus by Yida.\u00a0\u21a9</p> </li> <li> <p>Overview of the CAN Bus Protocol on DigiKey TechForum.\u00a0\u21a9</p> </li> </ol>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/","title":"PE3 8400P","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#details","title":"Details","text":"<p>Device Datasheet </p> <ul> <li>Device: PE3-8400P ECU by Performance Electronics.</li> <li>Bit Rate: 250 kbps. However, each message is published at different rates.</li> <li>Communication: Extended CAN.<sup>1</sup> Based on the SAE J1929 standard.</li> </ul> <p> </p> <p></p> <p>Device Datasheet </p> <ul> <li>Device: MCP2551 CAN Transceiver by Microchip.</li> <li>Communication: Converting between single-ended and differential-pair signals.</li> </ul> <p></p> <p>Warning</p> <p>The MCP2551 transceiver is discontinued and deprecated. This was selected due to the higher availability of documentation.</p>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#circuit","title":"Circuit","text":"<p>Info</p> <p>This ECU internally has a \\(120 \\Omega\\) termination resistor,</p>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#pinout","title":"Pinout","text":"Transceiver MCU VCC 5V GND GND RXD CAN_RD TXD CAN_TD"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#firmware-component-library","title":"Firmware Component Library","text":"<p>Library API Docs </p> <p>Source Code </p> <pre><code>classDiagram\ndirection TB\n\nnamespace SensorLayer {\n    class IEcu {\n        &lt;&lt;interface&gt;&gt;\n        +CanIdList() const std::vector&lt;uint32_t&gt;&amp;\n        +LatestCanId() uint32_t\n        +NewMessageArrived() bool\n        +Update() void\n        +Rpm() int16_t\n        +Tps() float\n        +FuelOpenTime() float\n        +IgnitionAngle() float\n        +BarometerPressure() float\n        +Map() float\n        +Lambda() float\n        +BatteryVoltage() float\n        +AirTemperature() float\n        +CoolantTemperature() float\n        +AnalogInputVoltage(uint8_t index) float\n    }\n\n    class Pe3{\n        +CanIdList() const std::vector&lt;uint32_t&gt;&amp;\n        +LatestCanId() uint32_t\n        +NewMessageArrived() bool\n        +Update() void\n        +Rpm() int16_t\n        +Tps() float\n        +FuelOpenTime() float\n        +IgnitionAngle() float\n        +BarometerPressure() float\n        +Map() float\n        +Lambda() float\n        +BatteryVoltage() float\n        +AirTemperature() float\n        +CoolantTemperature() float\n        +AnalogInputVoltage(uint8_t index) float \\n \\n\n\n\n        \\n \\n +PressureUnit() PressureType\n        +TemperatureUnit() TemperatureType\n        +FrequencyHertz(uint8_t index) float\n        +AnalogInputThermistorVoltage(uint8_t index) float\n        +RpmRate() float\n        +TpsPercentageRate() float\n        +MapRate() float\n        +MassAirFlowLoadRate() float\n        +LambdaMeasured(uint8_t index) float\n        +PwmDutyCycle(uint8_t index) float\n        +PercentSlip() float\n        +DrivenWheelRateOfChange() float\n        +DesiredValue() float\n        +DrivenAverageWheelSpeed() float\n        +NonDrivenAverageWheelSpeed() float\n        +IgnitionCompensation() float\n        +IgnitionCutPercentage() float\n        +DrivenWheelSpeed(uint8_t index) float\n        +NonDrivenWheelSpeed(uint8_t index) float\n        +FuelCompensationAcceleration() float\n        +FuelCompensationStarting() float\n        +FuelCompensationAirTemperature() float\n        +FuelCompensationCoolantTemperature() float\n        +FuelCompensationBarometer() float\n        +FuelCompensationManifoldAbsolutePressure() float\n        +IgnitionCompensationAirTemperature() float\n        +IgnitionCompensationCoolantTemperature() float\n        +IgnitionCompensationBarometer() float\n        +IgnitionCompensationManifoldAbsolutePressure() float\n    }\n}\n\nnamespace Platform Layer {\n    class ICan {\n        &lt;&lt;interface&gt;&gt;\n    }\n}\n\nIEcu &lt;-- Pe3\nPe3 ..&gt; ICan\n\n\nend</code></pre>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#can-bus-reading-strategy","title":"CAN Bus Reading Strategy","text":"<p>To make data available, the ECU component undergoes the following steps in order:</p> <ul> <li>The <code>ICan</code> interface feeds the byte array and CAN ID to the ECU.</li> <li>Check the CAN ID to identify the <code>FramePEx</code>.</li> <li>Create <code>FramePEx</code> by providing the byte array for parsing.</li> <li>Utilize the <code>FramePEx</code> methods to access the data.</li> <li>Store a local copy of the resulting data. </li> </ul>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#nomenclature","title":"Nomenclature","text":"<p>We will refer to the following terms in correspondence to the ECU datasheet:</p> <ul> <li>Frame \u2014 A <code>PEx</code> message.</li> <li>Field \u2014 A data value encapsulated within a frame.</li> <li>Frame Format \u2014 The arrangement of bytes and bits representing each field.</li> </ul> <p>Instead of defining similar, unique parsing algorithms for each individual frame, it was decided to categorize each frame by their formats in favor of maintaining only a shared set of common parsing algorithms.</p>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#message-formatting","title":"Message Formatting","text":""},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#frame-format-1","title":"Frame Format 1","text":"Data Field Number of Bytes 1 2 2 2 3 2 4 2"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#frame-format-2","title":"Frame Format 2","text":"Data Field Number of Bytes 1 2 2 2 3 2"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#frame-format-3","title":"Frame Format 3","text":"Data Field Number of Bytes 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#frame-format-4","title":"Frame Format 4","text":"Data Field Number of Bytes 1 2 2 2 3 2 4 1"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#frame-format-5","title":"Frame Format 5","text":"Data Field Number of Bytes 1 2 2 2 3 1 4 1 5 1 6 1 <p>Example</p> <p>The CAN message with a CAN ID of <code>0xCFFF148</code> would be referred to as Frame PE2. Notice that PE2 has four fields:</p> <ul> <li>Barometer</li> <li>MAP</li> <li>Lambda</li> <li>Pressure Type</li> </ul> <p>Observing the arrangements of fields and bytes, <code>FramePE2</code> seems to follow <code>FrameFormat4</code>. In other words, there are four data fields where fields 1-3 (Barometer, MAP, Lambda) are represented with 2 bytes while the last field (Pressure Type) is represented with only 1 byte.</p>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#field-parsing-algorithm","title":"Field Parsing Algorithm","text":""},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#2-byte-fields","title":"2-Byte Fields","text":"<p>It is worth noting that for every <code>FrameFormatx</code>, the 2-byte fields are received before the 1-byte fields. Each <code>FrameFormatx</code> class internally defines a vector initialized at the length of the number of 2-byte fields. </p> <p>Having a known number of byte pairs and a known maximum length of 8 bytes in the receiving buffer (per the CAN standard) allows us to handle the indexes of each <code>FrameFormatx</code> class.</p> <p>Each <code>FramePEx</code> class inherits its corresponding <code>FrameFormatx</code> along with its vector of fields. Upon receiving a byte array for input at initialization, the constructor of <code>FrameFormatx</code> is utilized to begin parsing each fields:</p> <ul> <li>Compute the <code>max_index</code> by halving the length of the <code>fields</code> vector.</li> <li>Iterate through the receiving buffer byte array:<ul> <li>Grab <code>LowByte</code> and <code>HighByte</code> from the receiving buffer, advancing the index accordingly.</li> <li>Perform the Byte Pair Parsing Algorithm.</li> <li>Store the computed output into <code>fields</code>.</li> </ul> </li> </ul>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#1-byte-fields","title":"1-Byte Fields","text":"<p>These fields are stored exactly as they were first received without modification. This occurs after parsing 2-byte fields.</p>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#1-bit-fields","title":"1-Bit Fields","text":"<p>For <code>FramePE2</code> and <code>FramePE6</code>, the final bit indicates the tempeature and pressure type, respectively.</p> <p>This serves to mark if the temperature is being expressed as Fahrenheit/Celsius or the pressure as psi/Kilo-Pascal \u2014 depending on whether the type bit is low (<code>0x00</code>) or high (<code>0x01</code>).</p>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#byte-pair-parsing-algorithm","title":"Byte Pair Parsing Algorithm","text":"<p>An Extended CAN Message can contain up to 8 bytes of data. The ECU datasheet specifies that it may transmit data represented with two bytes: a low byte and a high byte. Within the stream of CAN messages, the low byte comes first and is then accompanied by the high byte.</p> <p>Info</p> <p>This byte parsing algorithm applies only to data that are represented with two bytes. Those represented with only one byte are stored as they were received.</p> <p>The datasheet defines 2-byte data to be stored as the following:</p> \\[ Num = HighByte*256 + LowByte \\] <p>Multiplying by 256 is equivalent to bit-shifting the <code>HighByte</code> to the left by 8. This is simply combining to bytes into a 16-bit value.</p> <p>The complete byte-parsing algorithm:</p> <pre><code>Num = HighByte*256 + LowByte\nif (Num &gt; 32767) then\n    Num = Num - 65536\nendif\n</code></pre> <p>The complete algorithm indicates that we must account for bit overflow. Having to prohibit <code>Num</code> from exceeding 32767 suggests that this is a signed 16-bit integer (Two's Complement). That is, the MSB represents the signage and the numerical value of the data is represented with the remaining 15 bits. Subtracting by 65536 is a means of resetting the value to its negative domain within the 15-bit range (-32768 to +32767).</p> \\[ 2^{15 \\ bits} - 1 = 32767 \\] \\[ 2^{16 \\ bits} = 2^{15 \\ bits} * 2 = 65536 \\] <p>Until bit overflow is accounted for, 32-bits are first allocated to store <code>Num</code>. Otherwise, in the case of bit overflow, unexpected values may occur. The final output is a 16-bit integer by masking.</p>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#field-computing","title":"Field Computing","text":"<p>In the process of creating a <code>FramePEx</code>, only the following have occurred with the byte array of data from the CAN bus:</p> <ul> <li>The layout of fields have been identified, per the inherited <code>FrameFormatx</code>.</li> <li>The bytes of each field are parsed according to the frame's format.</li> <li>The results are stored as integers in the <code>fields</code> vector.</li> </ul> <p>These steps are handled entirely by the <code>FrameFormatx</code> classes.</p> <p>The final step to computing the final output is to multiply a value from <code>fields</code> with the field's corresponding <code>ResolutionPerBit</code> \u2014 as specified in the ECU datasheet. The <code>ResolutionPerBit</code> is field-specific, and therefore this last step is frame-specific and handled by the <code>FramePEx</code> class. The data is finally represented in its appropriate floating-point form as a field in a frame.</p>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#how-to-use","title":"How to Use","text":"<p>Example</p> <p>Reading from the PE3 ECU firmware component.</p> <pre><code>// Standard Libraries\n#include &lt;memory&gt;\n\n// DFR Custom Dependencies\n#include \"app.hpp\"\n#include \"Platform/CAN/Interfaces/ican.hpp\"\n#include \"Sensor/ECU/PE3/pe3.hpp\"\n\nvoid cppMain() {\n    // Assume this pointer has initialized to a\n    // CAN peripheral and all platform-specific\n    // configurations have already been performed.\n    std::shared_ptr&lt;platform::ICan&gt; can_bus;\n\n    // Initialize the PE3 ECU\n    auto pe3_ecu = std::make_unique&lt;sensor::Pe3&gt;(can_bus);\n\n    float manifold_absolute_pressure = 0.0f;\n    float battery_voltage = 0.0f;\n\n    for(;;) {\n        if (pe3_ecu-&gt;NewMessageArrived()) {\n            // Disable interrupts here\n            pe3_ecu-&gt;Update();\n            uint32_t can_id = pe3_ecu-&gt;LatestCanId();\n\n            switch(can_id) {\n            case FramePe2Id:\n                manifold_absolute_pressure = pe3_ecu-&gt;Map();\n                break;\n\n            case FramePe6Id:\n                battery_voltage = pe3_ecu-&gt;BatteryVoltage();\n                break;\n            }\n            // Re-enable interrupts here\n        }\n    }\n}\n</code></pre> <p>Example</p> <p>Reading from the PE3 ECU firmware component through the <code>IEcu</code> abstract interface.</p> <pre><code>// Standard Libraries\n#include &lt;memory&gt;\n\n// DFR Custom Dependencies\n#include \"app.hpp\"\n#include \"Platform/CAN/Interfaces/ican.hpp\"\n#include \"Sensor/ECU/PE3/iecu.hpp\"\n#include \"Sensor/ECU/PE3/pe3.hpp\"\n\nvoid cppMain() {\n    // Assume this pointer has initialized to a\n    // CAN peripheral and all platform-specific\n    // configurations have already been performed.\n    std::shared_ptr&lt;platform::ICan&gt; can_bus;\n\n    // Initialize the PE3 ECU\n    std::unique_ptr&lt;sensor::IEcu&gt; ecu(nullptr);\n    ecu = std::make_unique&lt;sensor::Pe3&gt;(can_bus);\n\n    float manifold_absolute_pressure = 0.0f;\n    float battery_voltage = 0.0f;\n\n    for(;;) {\n        if (pe3_ecu-&gt;NewMessageArrived()) {\n            pe3_ecu-&gt;Update();\n            uint32_t can_id = pe3_ecu-&gt;LatestCanId();\n\n            manifold_absolute_pressure = pe3_ecu-&gt;Map();\n            battery_voltage = pe3_ecu-&gt;BatteryVoltage();\n        }\n    }\n}\n</code></pre> <p>Warning</p> <p>It is worth noting that due to interacting with the ECU using the abstract interface, the identification of CAN IDs is lost because that is ECU-specific information. Therefore, <code>IEcu</code> is more suitable for polling operations, not for receiving CAN messages using interrupts.</p> <p>One solution for implementing interrupts despite having abstracted away specific CAN IDs, may be to implement the Observer design pattern or some form of callback functions. At the time of this writing, this is not supported.</p>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#current-integration","title":"Current Integration","text":""},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#platform-implementation","title":"Platform Implementation","text":"<p>The ECU component depends on an implementation of the <code>ICan</code> interface to interact with the hardware's CAN peripheral and expects the following inputs:</p> <ul> <li>A byte array of data from the latest CAN message.</li> <li>The corresponding CAN ID.</li> </ul> <p>This is implemented with <code>BxCan_StmF4</code> by using interrupt signals. To more efficiently process CAN messages, we are interacting with the <code>Pe3</code> class directly (without the <code>IEcu</code> interface) to retain access to the ECU-specific CAN IDs. The BxCAN peripheral's interrupt mode and CAN ID filters are configured before reaching the super-loop.</p> <p>Note that the filters are configured by providing lower-bound and higher-bound values to specify a range for grabbing our desirable CAN ID. </p> <pre><code>// Standard Libraries\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\n// ST HAL Dependencies\n#include \"can.h\"\nextern CAN_HandleTypeDef hcan1;\n\n// DFR Custom Dependencies\n#include \"app.hpp\"\n#include \"Platform/CAN/STM/F4/bxcan_stmf4.hpp\"\n#include \"Platform/CAN/Interfaces/ican.hpp\"\n#include \"Sensor/ECU/PE3/iecu.hpp\"\n#include \"Sensor/ECU/PE3/pe3.hpp\"\n\n// CAN Bus Interrupt Callback\nstd::shared_ptr&lt;platform::BxCanStmF4&gt; bx_can_callback_ptr(nullptr);\n\nvoid HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan) {\n    bx_can_callback_ptr-&gt;ReceiveCallback();\n}\n\nusing ReceiveInterruptMode = platform::BxCanStmF4::ReceiveInterruptMode;\n\nvoid cppMain() {\n    // Initialize the microcontroller's CAN peripheral\n    auto bx_can_peripheral = std::make_shared&lt;platform::BxCanStmF4&gt;(hcan1);\n    std::shared_ptr&lt;platform::ICan&gt; can_bus = bx_can_peripheral;\n\n    // Initialize the Pe3 ECU\n    auto pe3_ecu = std::make_unique&lt;sensor::Pe3&gt;(can_bus);\n    const std::vector&lt;uint32_t&gt;&amp; can_id_list = pe3_ecu-&gt;CanIdList();\n\n    // Subscribe to messages with PE3's CAN IDs\n    for (const uint32_t&amp; can_id : can_id_list) {\n        bx_can_peripheral-&gt;ConfigureFilter((can_id &gt;&gt; 13), (can_id &amp; 0x1FFF));\n    }\n\n    bx_can_peripheral-&gt;Start();\n\n    bx_can_callback_ptr = bx_can_peripheral;\n    ReceiveInterruptMode rx_interrupt_mode = ReceiveInterruptMode::kFifo0MessagePending;\n    bx_can_peripheral-&gt;ConfigureReceiveCallback(rx_interrupt_mode);\n    bx_can_peripheral-&gt;EnableInterruptMode();\n\n    for(;;) {\n        // Process Pe3 data\n    }\n}\n</code></pre>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#cubemx-settings","title":"CubeMX Settings","text":"<p>Most settings are left to their default configurations.</p> <p>The Bit Timimng Parameters were configured until the Baud Rate matched that of the PE3: 250 kbps, as specified by the datasheet.</p> <p> </p> Bit timing parameters. <p> </p> Enabling interrupt signals. <p> </p> GPIO pin modes and assignments."},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#data-capture","title":"Data Capture","text":"<p>In favor of efficiency, this library was developed with a reverse-engineering approach. Data has been captured by using the Saleae Logic 8 analyzer and recorded with the Logic 2 Software. This allowed us to inspect the data and verify how to parse the information properly before developing the firmware.</p>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#connecting-to-the-can-bus","title":"Connecting to the CAN Bus","text":"<p>Saleae's pro analyzers may be able to read the voltages on the CAN bus (i.e., CAN Hi and Lo lines). In our case, we are unable to do this. However, that is only necessary if we wish to debug the CAN network.</p> <p>Instead, the logic analyzer was connected to the single-ended signals (i.e., CAN Rx and Tx) with the transceiver. This was recommended in Salae's User Guide.</p> <p></p> <p>Tip</p> <p>Some oscilloscopes offer the feature to decode CAN messages.</p>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#sample-data","title":"Sample Data","text":"<p>The following downloadable files contains sample data that can be opened through the Logic 2 Software application:</p> <ul> <li>Frames1to6.sal</li> <li>Frames7to16.sal</li> </ul> <p>Warning</p> <p>This data was captured while the vehicle remained stationary.</p> <p>Success</p> <p>This sample data was used to develop automated unit tests for testing the parsing algorithm implemented in the firmware.</p>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#regular-frame","title":"Regular Frame","text":"<p>Example</p> <p>Parsing the byte-array stored in the Data field of a recorded CAN message holding the PE1 Frame.</p> \\[ [ 0x1E, 0x05, 0xA5, 0x03, 0xFE, 0x00, 0x3C, 0x00 ] \\] <p>Following the steps of the field-parsing and byte-parsing algorithms, we begin by grabbing a pair of bytes. The first byte-pair <code>[0x1E, 0x05]</code> is associated to the first field of the PE1 frame: RPM. This equates to <code>[30, 5]</code> in decimal notation.</p> \\[ \\begin{aligned}     Num &amp;= HighByte * 256 + LowByte \\\\     &amp;= (5) * 256 + (30) \\\\     &amp;= \\boxed{1310} \\end{aligned} \\] \\[ \\begin{aligned}     RPM &amp;= Num * ResolutionPerBit \\\\     &amp;= = 1310 * (1) \\\\      &amp;= \\boxed{1310} \\end{aligned} \\] <p>To parse the next field, TPS, we must parse the next byte-pair: <code>[0xA5, 0x03]</code>.</p> \\[ \\begin{aligned}     Num &amp;= HighByte * 256 + LowByte \\\\     &amp;= (0xA5) * 256 + (0x03) \\\\     &amp;= \\boxed{933} \\end{aligned} \\] \\[ \\begin{aligned}     TPS &amp;= Num * ResolutionPerBit \\\\     &amp;= 933 * (0.1) \\\\      &amp;= \\boxed{93.3} \\end{aligned} \\] <p>This process is repeated for the rest of the byte array to parse the remaining fields (Fuel Open Time and Ignition Angle).</p>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#pressure-unit","title":"Pressure Unit","text":"<p>Example</p> <p>Parsing the Data field of a recorded CAN message holding the PE2 Frame.</p> <p> </p> PE2 Frame read on the logic analyzer. <p>Parsing the Barometer, MAP, and Lambda fields of the PE2 frame follows the same process demonstrated in the previous example. However, note that this frame indicates the Pressure in PSI or Kilo-Pascal by encoding with only 1 bit. This bit is stored in the second-to-last byte of the CAN message's Data. In this case, <code>0x00</code> is received and therefore the pressure is expressed in PSI.</p>"},{"location":"Data%20Acquisition/Sensor/ECU/pe3/#temperature-unit","title":"Temperature Unit","text":"<p>Example</p> <p>Parsing the Data field of a recorded CAN message holding the PE6 Frame.</p> <p> </p> PE6 Frame read on the logic analyzer. <p>Likewise, the PE6 frame delegates a bit for expressing the temperature in Fahrenheit or Celsius. In this sample output, <code>0x00</code> is received and therefore the temperature is expressed in Fahrenheit.</p> <ol> <li> <p>Extended CAN is synonymous to CAN 2.0B.\u00a0\u21a9</p> </li> </ol>"},{"location":"Data%20Acquisition/Sensor/Gyroscope/","title":"Accelerometer","text":""},{"location":"Data%20Acquisition/Sensor/Gyroscope/#description","title":"Description","text":"<p>Reading the angular velocity in \\(\\degree /s\\) or \\(rad/s\\) of the X, Y, and Z axis.</p>"},{"location":"Data%20Acquisition/Sensor/Gyroscope/#supported-sensors","title":"Supported Sensors","text":"<pre><code>classDiagram\n\nnamespace SensorLayer {\n    class IGyroscope {\n        &lt;&lt;interface&gt;&gt; \n\n    }\n\n    class L3GD20H { }\n}\n\nnamespace Platform Layer {\n    class II2C {\n        &lt;&lt;interface&gt;&gt;\n    }\n}\n\nIGyroscope &lt;.. L3GD20H\nL3GD20H --&gt; II2C\n\nlink L3GD20H \"l3gd20h/\"\n\nend</code></pre>"},{"location":"Data%20Acquisition/Sensor/Gyroscope/l3gd20h/","title":"L3GD20H","text":""},{"location":"Data%20Acquisition/Sensor/Gyroscope/l3gd20h/#details","title":"Details","text":"<p>Sensor Datasheet </p> <p></p> <ul> <li>Sensor: LSM303DLHC Gyroscope.<ul> <li>Sensor is made by ST.</li> <li>Breakout board is provided by Adafruit.</li> </ul> </li> <li>Frequency:</li> <li>Communication: I2C.</li> <li>Senses rotations in the range of \\(-245 \\ \\degree /s\\) to \\(245 \\ \\degree /s\\)</li> </ul>"},{"location":"Data%20Acquisition/Sensor/Gyroscope/l3gd20h/#pinout","title":"Pinout","text":""},{"location":"Data%20Acquisition/Sensor/Gyroscope/l3gd20h/#resources-and-calculations","title":"Resources and Calculations","text":"<p>If you are too lazy to read here is the list of the main resources used in addition to resources used for researching gyroscope:</p> <ul> <li>https://github.com/adafruit/Adafruit_L3GD20/blob/master/Adafruit_L3GD20.cpp</li> <li>https://www.pololu.com/file/0J731/L3GD20H.pdf</li> <li>https://studylibfr.com/doc/10064916/lab-3---gyro-and-acc-lab--1-</li> <li>https://electronics.stackexchange.com/questions/205658/converting-raw-gyro-l3gd20h-values-into-angles</li> </ul>"},{"location":"Data%20Acquisition/Sensor/Gyroscope/l3gd20h/#firmware","title":"Firmware","text":"<p>Library API Docs </p> <p>in order to obtain readable data from the gyroscope the raw data needs to be converted to DPS. The equation below demonstrates the conversion to DPS (the picture was from Adafruit's L3GD20 library from here https://github.com/adafruit/Adafruit_L3GD20/blob/master/Adafruit_L3GD20.cpp )</p> <p></p> <p>the sensitivity that the library used depends on the selected DPS and can be found in the L3GD20H datasheet. The picture below shows the available sensitivities. ( link for the site: https://www.pololu.com/file/0J731/L3GD20H.pdf)</p> <p></p> <p>Note that sensitivity is in mDPS/digit so you need to convert it to DPS/digit by multiplying by 10^-3</p>"},{"location":"Data%20Acquisition/Sensor/Gyroscope/l3gd20h/#remarks","title":"Remarks","text":"<p>This first remark isn't very important but I think it might be worth mentioning. generally, a whole iteration of the code will typically take around a few microseconds to fully iterate(specifically for the gyroscope code) . Normally this would be fine, however, each iteration of code needs data from the gyroscope to function properly. This is where to problem occurs, the default ODR for the gyroscope is around 100hz. Meaning that it has a period of around 10ms (1/100). this is found by looking in the L3GD20H datasheet</p> <p>The register that keeps track of the ODR is seen below</p> <p></p> <p>The table that describes the different combinations of ODR can also be seen below</p> <p></p> <p>Note that LOW_ODR is disabled by default so you don't have to worry about that value</p> <p>Now when looking at all the default values for CTRL1( where ODR is changed)</p> <p></p> <p>looking at the default register value table and comparing it to the ODR table you can see that the default ODR is 100 Hz with a cutoff frequency of 12.5 Hz. my main concern is that the code is utilizing uncessary resources since it will iterate a whole loop significantly faster than the gyroscope can refresh its data. The problem wouldn't affect the results/data from the gyroscope but with some modification to the code we could potentially reduce the number of resources this code needs.</p>"},{"location":"Data%20Acquisition/Sensor/Gyroscope/l3gd20h/#hardware-interrupt","title":"Hardware Interrupt","text":"<p>This remark is more like a solution to my previous remark. The L3GD20H comes with two interrupts a programmable interrupt(INT1) and a data ready/fifo interrupt (INT2). Either of these interrupts could be used to eliminate unnecessary iteration of the code. </p>"},{"location":"Data%20Acquisition/Sensor/Gyroscope/l3gd20h/#saturation-and-inconsistencies","title":"Saturation and Inconsistencies","text":"<p>When looking at the data sheets, the L3GD20H has a Full Scale of 245 DPS which is unusual since most gyroscopes are typically in 250 DPS. In addition to being at an odd DPS, the L3GD20H datasheet gives the same sensitivity of 8.75 mDPS/digit for the full scale. This sensitivity is typically used for 250 DPS like the Adafruit L3GD20 library( note that the L3GD20 uses 250 DPS while the L3GD20H uses 245 DPS). This is confusing since 245 DPS is not the same as 250 DPS so it's kind of weird that the datasheet uses the same sensitivity used for a full scale of 250 DPS. Leading to my remark, when I max out the gyroscope, it maxes out at around 280 in both directions. Whereas the max value should be at around 245. I'm unsure if the provided sensitivity is off enough that it's making my max DPS 280 or if saturation is occurring or something else entirely. I haven't fully looked into this inconsistency, so this could be something to look into in the future. Luckily, when we did the testing for the gyroscope( basically comparing it with another gyroscope) the data was similar so the gyroscope is at least somewhat precise.</p>"},{"location":"Data%20Acquisition/Sensor/Gyroscope/l3gd20h/#migration-to-stm32-cube-ide","title":"Migration to STM32 Cube IDE","text":"<p>The migration to STM32's HAL allowed for the automation of some I2C initialization. This means that we no longer need to initialize some characteristics in the firmware. <pre><code>  hi2c1.Instance = I2C1;\n  hi2c1.Init.ClockSpeed = 100000;\n  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;\n  hi2c1.Init.OwnAddress1 = 0;\n  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;\n  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;\n  hi2c1.Init.OwnAddress2 = 0;\n  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;\n  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;\n</code></pre> The HAL basically is set to an I2C speed of 100Khz(Normal Mode) and an I2C slave address of 8 bits (7-bit slave address + R/W bit). For now the I2C lines are set to 100Khz but if needed can also be set to 400kHz mode. I will note that there is a possibility that there are no benefit/marginal benefits when moving to 400Khz since the actual ODR of the gyroscope isn't particularly fast. </p>"},{"location":"Data%20Acquisition/Sensor/Gyroscope/l3gd20h/#how-to-use","title":"How to Use","text":"<p>Example</p> <p>How to initialize the <code>L3GD20H</code> object and read the angular velocity of each axis by interacting with the <code>IGyroscope</code> interface.</p> <pre><code>#include &lt;iostream&gt;\n#include \"mbed.h\"\n#include \"../igyroscope.hpp\"\n#include \"../gyroscope_l3gd20h.hpp\"\n\nint main(){\n    short* degrees_per_second;\n    float* radians_per_second;\n\n    std::unique_ptr&lt;adapter::IGyroscope&gt; gyro\n        = std::make_unique&lt;adapter::Gyroscope_L3GD20H&gt;(I2C_SDA,I2C_SCL);\n\n    while (true) {\n        gyro-&gt;ComputeAngularVelocity();\n        degrees_per_second = gyro-&gt;GetDegreesPerSecond();\n        radians_per_second = gyro-&gt;GetRadiansPerSecond();\n\n        printf(\"Degrees Per Second: X = %d, Y = %d, Z = %d\", degrees_per_second[0], degrees_per_second[1], degrees_per_second[2]);\n        printf(\"   \");\n        printf(\"Radians per second =  X = %f, Y = %f, Z = %f  \\n\", radians_per_second[0],radians_per_second[1], radians_per_second[2]);\n    }             \n}\n</code></pre>"},{"location":"Data%20Acquisition/Sensor/Linear%20Potentiometer/","title":"Suspension Travel Potentiometers","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Sensor/Linear%20Potentiometer/#description","title":"Description","text":"<ul> <li>Stakeholder: Suspension lead</li> <li>Use Case: Reading the displacement to measure measure the suspension travel and shock absorption. A total of 4 potentiometers must be mounted on the vehicle.</li> </ul>"},{"location":"Data%20Acquisition/Sensor/Linear%20Potentiometer/#supported-sensors","title":"Supported Sensors","text":"<pre><code>classDiagram\n\nnamespace SensorLayer {\n    class ILinearPotentiometer {\n        &lt;&lt;interface&gt;&gt; \n        +DisplacementInches()* float\n        +DisplacementMillimeters()* float\n    }\n\n    class SLS1322 { }\n}\n\nnamespace Platform Layer {\n    class IAdc {\n        &lt;&lt;interface&gt;&gt;\n    }\n}\n\nILinearPotentiometer &lt;-- SLS1322\nSLS1322 ..&gt; IAdc\n\nlink SLS1322 \"SLS_1322-3/\"\n\nend</code></pre>"},{"location":"Data%20Acquisition/Sensor/Linear%20Potentiometer/SLS_1322-3/","title":"SLS 1322-3","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Sensor/Linear%20Potentiometer/SLS_1322-3/#details","title":"Details","text":"<p>Sensor Datasheet </p> <p></p> <ul> <li>Sensor: SLS 1322-3 Linear Potentiometer by Active Sensors.</li> <li>Frequency: 3 to 4 Hz.</li> <li>Communication: Analog.</li> <li>Max Rod Length: 3 inches.</li> <li>Linear Function of Kilo-Ohm to Distance: \\(25 \\  k\\Omega + 100\\).<ul> <li>Increases by 1 Kilo-Ohm every 25 millimeters.</li> <li>\\(125 \\ mm \\approx 1 \\ k\\Omega\\)</li> <li>\\(450 \\ mm \\approx 14 \\ k\\Omega\\) </li> </ul> </li> </ul>"},{"location":"Data%20Acquisition/Sensor/Linear%20Potentiometer/SLS_1322-3/#pinout","title":"Pinout","text":"Sensor MCU VCC 3.3V GND GND Signal Analog Input"},{"location":"Data%20Acquisition/Sensor/Linear%20Potentiometer/SLS_1322-3/#mounting","title":"Mounting","text":""},{"location":"Data%20Acquisition/Sensor/Linear%20Potentiometer/SLS_1322-3/#firmware","title":"Firmware","text":"<p>Library API Docs </p> <p>Source Code </p>"},{"location":"Data%20Acquisition/Sensor/Linear%20Potentiometer/SLS_1322-3/#implementation-details","title":"Implementation Details","text":"<p>This library allows for polling the ADC<sup>1</sup>. This consists of performing the following steps:</p> <ul> <li>Starting the ADC peripheral.</li> <li>Polling for an analog-to-digital conversion. A timeout waiting value can be specified.</li> <li>Retrieving the output from the ADC. </li> </ul> <p>The accuracy of the output is dependent on the resolution of the ADC and is represented as an integer after quantization. In other words, the Quantized Count<sup>2</sup> of the analog signal is in the range of \\([0, 2^{resolution} - 1]\\).</p> <p>Example</p> <p>The STM32 Nucleo-F429ZI microcontroller has ADCs with a resolution of 12-bits. So, the range of the integer value of the measured analog signal is \\([0, 4095]\\).</p> <p>The ADC's resolution is a known constant defined by the hardware. This is used to compute ratios between the measured Quantized Count and the resolution. The value of the ratio varies between \\([0.0, 1.0]\\) depending on the retraction/displacement of the linear potentiometer.</p> \\[ Retraction \\ Ratio = Quantized \\ Count / Resolution \\] \\[ Displacement \\ Ratio = 1 - Retraction \\ Ratio \\] <p>Finally, the displacement ratio is multiplied with the linear potentiometer's maximum length in inches or millimeters. The length of the sensor's rod at full extension is about \\(3\\) inches.</p>"},{"location":"Data%20Acquisition/Sensor/Linear%20Potentiometer/SLS_1322-3/#cubemx-settings","title":"CubeMX Settings","text":"<p>Per analog pin:</p> <ul> <li>Enable the anlog channel, such as <code>IN0</code> (channel 0)</li> <li>Continuous conversion: <code>Enabled</code></li> </ul>"},{"location":"Data%20Acquisition/Sensor/Linear%20Potentiometer/SLS_1322-3/#how-to-use","title":"How to Use","text":"<pre><code>classDiagram\n\nnamespace SensorLayer {\n    class ILinearPotentiometer {\n        &lt;&lt;interface&gt;&gt; \n        +DisplacementInches()* float\n        +DisplacementMillimeters()* float\n    }\n\n    class SLS1322 {\n        -kMaxResolution: uint16_t = 0x0FFF\n        -kMaxLengthInches: uint8_t = 3\n\n        +DisplacementInches()* float\n        +DisplacementMillimeters()* float\n\n        -ReadQuantizedInput()\n        -DisplacementRatio()\n    }\n}\n\nnamespace Platform Layer {\n    class IAdc {\n        &lt;&lt;interface&gt;&gt;\n    }\n}\n\nILinearPotentiometer &lt;-- SLS1322\nSLS1322 ..&gt; IAdc\n\nend</code></pre> <p>Example</p> <p>How to initialize the <code>SLS1322</code> object and read the analog signal by interacting with the <code>ILinearPotentiometer</code> interface.</p> <pre><code>// Standard Libraries\n#include &lt;memory&gt;\n\n// ST HAL Dependencies\n#include \"adc.h\"\nextern ADC_HandleTypeDef hadc1;\n\n// DFR Custom Dependencies\n#include \"app.hpp\"\n#include \"Sensor/LinearPotentiometer/ilinear_potentiometer.hpp\"\n#include \"Sensor/LinearPotentiometer/sls1322.hpp\"\n\nvoid cppMain() {\n    std::unique_ptr&lt;sensor::ILinearPotentiometer&gt; lin_pot(nullptr);\n    lin_pot = std::make_unique&lt;sensor::SLS1322&gt;(hadc1);\n\n    float displacement_inches = 0.0f;\n    displacement_inches = lin_pot-&gt;DisplacementInches();\n}\n</code></pre> <ol> <li> <p>STM32F4 HAL User Manual, page 60, section Polling mode IO operation.\u00a0\u21a9</p> </li> <li> <p>More information on analog signal quantization.\u00a0\u21a9</p> </li> </ol>"},{"location":"Data%20Acquisition/Supported%20Platforms/","title":"Supported Platforms","text":""},{"location":"Data%20Acquisition/Supported%20Platforms/STMicroelectronics/stmicroelectronics/","title":"STMicroelectronics","text":"<p>This page was last updated: September 3, 2024</p>"},{"location":"Data%20Acquisition/Supported%20Platforms/STMicroelectronics/stmicroelectronics/#f4-product-line","title":"F4 Product Line","text":""},{"location":"Data%20Acquisition/Supported%20Platforms/STMicroelectronics/stmicroelectronics/#gpio","title":"GPIO","text":"<pre><code>classDiagram\ndirection LR\n\nnamespace Platform Layer {\n    class IGpio {\n        &lt;&lt;interface&gt;&gt;\n\n        +Read() bool\n        +Write()\n        +ToggleDetected() bool\n    }\n\n    class GpioStmF4 {\n\n        +Read() bool\n        +Write()\n        +ToggleDetected() bool\n\n        +InterruptCallback()\n    }\n}\n\nend</code></pre>"},{"location":"Data%20Acquisition/Supported%20Platforms/STMicroelectronics/stmicroelectronics/#reading","title":"Reading","text":"<p>Example</p> <p>Reading from a GPIO (port F, pin 15).</p> <pre><code>void ReadFromGpio() {\n    platform::GpioStmF4 gpio(GPIOF, GPIO_PIN_15);\n    bool signal = gpio.Read();\n\n    if (signal) {\n        printf(\"Signal is HIGH\\n\");\n    }\n    else {\n        printf(\"Signal is LOW\\n\");\n    }\n}\n</code></pre>"},{"location":"Data%20Acquisition/Supported%20Platforms/STMicroelectronics/stmicroelectronics/#writing","title":"Writing","text":"<p>Example</p> <p>Outputting a signal.</p> <pre><code>void WriteToGpio() {\n    platform::GpioStmF4 gpio(GPIOF, GPIO_PIN_15);\n\n    printf(\"Outputing signal\\n\");\n    gpio.Write(true);\n\n    printf(\"Turning off signal\\n\");\n    gpio.Write(false);\n}\n</code></pre> <p>Warning</p> <p>The <code>.Write()</code> method has not been tested on physical hardware.</p>"},{"location":"Data%20Acquisition/Supported%20Platforms/STMicroelectronics/stmicroelectronics/#interrupt-callback","title":"Interrupt Callback","text":"<p>Example</p> <p>Implementing a callback function. Assume that the GPIO peripheral and pin has been configured on CubeMX for triggering an interrupt.</p> <p>Note that the <code>.ToggleDetected()</code> method automatically clears the internal flag.</p> <pre><code>std::shared_ptr&lt;platform::GpioStmF4&gt; gpio_callback_ptr(nullptr);\n\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {\n    gpio_callback_ptr-&gt;InterruptCallback(GPIO_Pin);\n}\n\nint main() {\n    auto toggle_switch = std::make_shared&lt;platform::GpioStmF4&gt;(GPIOF, GPIO_PIN_15);\n    gpio_callback_ptr = toggle_switch;\n\n    for(;;) {\n        if (toggle_switch.ToggleDetected()) {\n            printf(\"GPIO state changed\\n\");\n        }\n    }\n}\n</code></pre>"},{"location":"Data%20Acquisition/Supported%20Platforms/STMicroelectronics/stmicroelectronics/#basic-extended-can","title":"Basic Extended CAN","text":"<pre><code>classDiagram\ndirection LR\n\nnamespace Platform Layer {\n    class ICan {\n        &lt;&lt;interface&gt;&gt; \n        Receive(uint8_t rx_buffer[kMaxBytes])\n        Transmit(uint8_t tx_buffer[kMaxBytes])\n        MessageArrivedFlag() bool\n        ClearMessageArrivedFlag()\n        LatestCanId() uint32_t\n        Start()\n        EnableInterruptMode()\n        DisableInterruptMode()\n    }\n\n    class BxCanStmF4 {\n        Receive(uint8_t rx_buffer[kMaxBytes])\n        Transmit(uint8_t tx_buffer[kMaxBytes])\n        MessageArrivedFlag() bool\n        ClearMessageArrivedFlag()\n        LatestCanId() uint32_t\n        Start()\n        EnableInterruptMode()\n        DisableInterruptMode() \\n\n\n\n        \\n ConfigureFilter(uint32_t filder_id_high, uint32_t filter_id_low)\n        ConfigureReceiveCallback(ReceiveInterruptMode mode)\n        ReceiveCallback()\n    }\n}\n\nICan &lt;-- BxCanStmF4\nend</code></pre> <ul> <li>The <code>BxCanStmF4</code> is a wrapper class that offers simple configurations of the device's BxCAN (Basic Extended) peripheral.</li> <li>This peripheral is only a CAN controller. So, an external CAN transceiver is required.</li> <li>An implementaion of the <code>ICan</code> abstract interface.</li> </ul> <p>Warning</p> <p>As of now, this implementation only offers support for reading Extended CAN. Transmission and Classic CAN are not yet supported.</p> <ul> <li>It is up to the developer how to make use of this library while following the steps recommended by ST's CAN Firmware Driver API Description<sup>1</sup>.</li> </ul> <p>Tip</p> <p>STM32CubeMx's code generation for the handle to the CAN peripheral already provides hardware initialization. Configurations and pin assignment is done using the <code>.ioc</code> file.</p> <p>In other words, this class offers configuration to the CAN peripheral after the configurations from CubeMX have been called.</p> <p>Steps:</p> <ul> <li>With initializattion and pin assignment already handled, pass the handle to the peripheral (<code>hcanx</code>) to <code>BxCanStmF4</code>'s constructor.</li> <li>Configure the device's filter banks as a means of subscribing to certain CAN IDs.</li> <li>Start the CAN module to start receiving/sending messages.</li> <li>If using interrupt mode, configure the callback function and activate the notifications.</li> </ul>"},{"location":"Data%20Acquisition/Supported%20Platforms/STMicroelectronics/stmicroelectronics/#filter-banks","title":"Filter Banks","text":"<p>Can be enabled using <code>ConfigureFilter()</code>. Every indificual call to this method will initialize a Filter Bank in hardware and is used to define a range of CAN IDs to listen. Using this given range, the invdividual filter bank will accept CAN messages and place them into the FIFO queue.</p> <p>Up to 27 filters can be configured and they are separately owned by 2 FIFO queues. These queues and filter bakns can be configured separately, but the current implementation only assigns a CAN ID to each filter. </p> <p>Filter bank scale organization, bit-shifting per the registers for an extended ID The implementation of automatically shifts the lower-bound value of the CAN ID range to the left by 3. This is necessary to provide the Extended CAN ID due to the <code>IDE</code>, <code>RTR</code>, and <code>0</code> register fields, as shown below in the Mapping row <sup>2</sup>.</p> <p></p> <p>Example</p> <p>Configuring a single filter bank by defining a the higher and lower bounds of acceptable CAN IDs.</p> <pre><code>void ConfigureFilterBank(uint8_t can_id) {\n    // Assume that CubeMX code for `hcan1` has already occured\n    platform::BxCanStmF4 bx_can_peripheral(hcan1);\n    static constexpr uint16_t kHigherBoundMask = 0x1FFF;\n    bx_can_peripheral.ConfigureFilter((can_id &gt;&gt; 13),\n                                    (can_id &amp; kHigherBoundMask));\n}\n</code></pre> <p>Warning</p> <p>As a library, this class needs more improvement in favor of additional configurability and robustness.</p> <p>Currently, the <code>BxCanStmF4</code> automatically assumes that each call to <code>ConfigureFilter()</code> is to be associated with a separate filter bank number. An internal count is maintained and incremented for this association. However, the following variables of the <code>CAN_FilterTypeDef filter_</code> object are all hard-coded:</p> <ul> <li><code>FilterMarkID</code> high and low</li> <li><code>FilterFIFOAssignment</code></li> <li><code>FilterMode</code></li> <li><code>FilterScale</code></li> <li><code>SlaveStartFilterBank</code></li> </ul> <p>Each of these are to be assigned values from macros defined in <code>stm32f4xx_hal_can.h</code>. One way possible approach is to use C++ enums as demonstrated in the next section for configuring Interrupt Modes.</p>"},{"location":"Data%20Acquisition/Supported%20Platforms/STMicroelectronics/stmicroelectronics/#interrupt-mode","title":"Interrupt Mode","text":"<p>The ST HAL library expects the callback function of an interrupt signal to be overwritten and provided in the global scope. So, multiple things need access to the <code>BxCanStmF4</code> object:</p> <ul> <li>The interrupt callback function in the global scope.</li> <li>Sensor/Application components in their separate, local scope.</li> <li>The <code>ICan</code> abstract interface.</li> </ul> <p>To support shareability, <code>std::shared_ptr</code> are highly encouraged over <code>std::unique_ptr</code>.</p> <p>The <code>ConfigureReceiveCallback(ReceiveInterruptMode mode)</code> supports the following interrupt modes:</p> <ul> <li>New message is pending in FIFO queue 0.</li> <li>FIFO queue 0 is full.</li> <li>FIFO queue 0 is overrun.</li> <li>New message is pending in FIFO queue 1.</li> <li>FIFO queue 1 is full.</li> <li>FIFO queue 1 is overrun.</li> </ul> <p>These options are based on the macros offered in <code>stm32f4xx_hal_can.h</code>:</p> <pre><code>/* Receive Interrupts */\n#define CAN_IT_RX_FIFO0_MSG_PENDING ((uint32_t)CAN_IER_FMPIE0)  /*!&lt; FIFO 0 message pending interrupt */\n#define CAN_IT_RX_FIFO0_FULL        ((uint32_t)CAN_IER_FFIE0)   /*!&lt; FIFO 0 full interrupt            */\n#define CAN_IT_RX_FIFO0_OVERRUN     ((uint32_t)CAN_IER_FOVIE0)  /*!&lt; FIFO 0 overrun interrupt         */\n#define CAN_IT_RX_FIFO1_MSG_PENDING ((uint32_t)CAN_IER_FMPIE1)  /*!&lt; FIFO 1 message pending interrupt */\n#define CAN_IT_RX_FIFO1_FULL        ((uint32_t)CAN_IER_FFIE1)   /*!&lt; FIFO 1 full interrupt            */\n#define CAN_IT_RX_FIFO1_OVERRUN     ((uint32_t)CAN_IER_FOVIE1)  /*!&lt; FIFO 1 overrun interrupt         */\n</code></pre> <p>Example</p> <p>Sharing access to the <code>BxCanStmF4</code> object and configuring the interrupt signal to fire when a new CAN message is pending in FIFO queue 0.</p> <pre><code>// Standard Libraries\n#include &lt;memory&gt;\n\n// DFR Custom Dependencies\n#include \"Platform/CAN/STM/F4/bxcan_stmf4.hpp\"\n#include \"Platform/CAN/Interfaces/ican.hpp\"\n\n// CAN Bus Interrupt Callback\nstd::shared_ptr&lt;platform::BxCanStmF4&gt; bx_can_callback_ptr(nullptr);\n\nvoid HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan) {\n    bx_can_callback_ptr-&gt;ReceiveCallback();\n}\n\nusing ReceiveInterruptMode = platform::BxCanStmF4::ReceiveInterruptMode;\n\nvoid EnableCanBusInterrupts() {\n    // Initialize BxCanStmF4 and ICan pointers\n    auto bx_can_peripheral = std::make_shared&lt;platform::BxCanStmF4&gt;(hcan1);\n    std::shared_ptr&lt;platform::ICan&gt; can_bus = bx_can_peripheral;\n\n    // Pass the BxCanStmF4 object to Pe3\n    auto pe3_ecu = std::make_unique&lt;sensor::Pe3&gt;(can_bus);\n    const std::vector&lt;uint32_t&gt;&amp; can_id_list = pe3_ecu-&gt;CanIdList();\n\n    // Pass the BxCanStmF4 object to the global interrupt pointer\n    bx_can_callback_ptr = bx_can_peripheral;\n\n    bx_can_peripheral-&gt;Start();\n\n    // Configure the Interrupt Mode\n    ReceiveInterruptMode rx_interrupt_mode = ReceiveInterruptMode::kFifo0MessagePending;\n    bx_can_peripheral-&gt;ConfigureReceiveCallback(rx_interrupt_mode);\n    bx_can_peripheral-&gt;EnableInterruptMode();\n}\n</code></pre> <p>Here, we are overwritting the <code>HAL_CAN_RxFifo0MsgPendingCallback()</code> function. There are other choices defined in <code>stm32f4xx_hal_can.h</code>:</p> <pre><code>// Callback functions\nvoid HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan);\nvoid HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan);\nvoid HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *hcan);\nvoid HAL_CAN_TxMailbox0AbortCallback(CAN_HandleTypeDef *hcan);\nvoid HAL_CAN_TxMailbox1AbortCallback(CAN_HandleTypeDef *hcan);\nvoid HAL_CAN_TxMailbox2AbortCallback(CAN_HandleTypeDef *hcan);\nvoid HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan);\nvoid HAL_CAN_RxFifo0FullCallback(CAN_HandleTypeDef *hcan);\nvoid HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan);\nvoid HAL_CAN_RxFifo1FullCallback(CAN_HandleTypeDef *hcan);\nvoid HAL_CAN_SleepCallback(CAN_HandleTypeDef *hcan);\nvoid HAL_CAN_WakeUpFromRxMsgCallback(CAN_HandleTypeDef *hcan);\nvoid HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan);\n</code></pre> <p>Tip</p> <p>Overwriting these functions are possible because, if you look at their implementation in <code>stm32f4xx_hal_can.c</code>, they are prepended with <code>__weak</code> in the function signature.</p> <p>The <code>ReceiveCallback()</code> function is responsible for:</p> <ul> <li>Retrieving the data from the newly received CAN message and storing the byte array into <code>rx_buffer</code>.</li> <li>Setting a flag to indicate that a new message has arrived for processing.</li> <li>Grabbing the CAN ID.</li> </ul> <p>If any modications are to be made to this function, be awre that <code>HAL_CAN_GetRxMessage()</code> must be the first instruction to occur. Otherwise, the callback function may not retrieve data from the new CAN message swiftly enough due to the time constraints of the interrupt signals.</p> <p>This library gives the consumer full control over enabling/disabling interrupt signals at any time with <code>EnableInterruptMode()</code> and <code>DisableInterruptMode</code>.</p> <ol> <li> <p>STM32F4 HAL and Low-Layer Drivers, Section 9.2: CAN Firmware Driver API Description, pg 91.\u00a0\u21a9</p> </li> <li> <p>STM32F4 Reference Manual, Section 32.7.4: Identifier Filtering, pg 1091.\u00a0\u21a9</p> </li> </ol>"}]}